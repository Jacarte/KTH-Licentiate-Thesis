\chapter{Introduction}
\label{chapter:intro}

\chapterprecishere{"\input{quotes/cinderella1.tex}"\par\raggedleft--- {\small\textup{MR. Cox} \textbf{1893}, Cinderella: Three hundred and forty-five variants \cite{cox1893cinderella}}}

% From Web 1.0 to JavaScript and how it support full-fledge applications
The first web browser, Nexus \cite{nexus}, appeared in 1990.
At that moment, web browsing was only about retrieving and showing small and static HTML web pages, \ie potential users read the content of pages without interactions further requesting a specific page.
The growing computing power of devices, the spread of the internet, and the need for more interaction and experiences for users encourage the idea of executing code along with web pages.
The Netscape browser made possible the execution of code on the client-side with the introduction of the JavaScript language in 1995.
Remarkably, JavaScript has been supported in all browsers since Netscape.
Nowadays, most of web pages include not only HTML, they also include JavaScript code that is executed in client computers.
The web browser is in charge of interpreting JavaScript in the user machine.
During the past decades, web browsers have become JavaScript language virtual machines, virtually evolving as operating systems that can run full-fledged applications, like video and audio players, animation creators, and PDF document renderers such as the one showing this document.

% Javascript problems
JavaScript is currently the most used scripting language in all modern web browsers. 
However, JavaScript faces several limitations related to the characteristics of the language. For example, any JavaScript engine requires the parsing and the recompilation of the JavaScript code, which implies a significant overhead.
On the other hand, JavaScript faces security issues \cite{10.1145/1190216.1190252}.
Because of these problems, the Web Consortium (W3C) standarized bytecode for the web environment with the \wasm (Wasm) language in 2015. 
\wasm becomes the fourth official language for the web with HTML, CSS, and JavaScript.

% Describe WebAssembly
Wasm is designed to be fast, portable, self-contained, and secure.
All \wasm programs are compiled ahead-of-time from source languages such as C/C++ and Rust.
\wasm is created by third-party compilers that might include optimizations like in the case of LLVM.  
The \wasm language defines its Instruction Set Architecture \cite{wasm_spec} as an abstraction close to machine code instructions but agnostic to CPU architectures. Thus,  web browsers can use it to compile it target architectures rapidly. Therefore, \wasm outperforms JavaScript in the browser.


Given the potential of \wasm, it evolves to be executed outside web browsers.
In 2019, the Bytecode Alliance \cite{bytecodealliance} proposed WebAssembly System Interface (WASI) \cite{WASI}. 
WASI standarized the execution of \wasm outside the browser with a POSIX system interface platform.
WASI standarizes the adoption of \wasm in heterogeneous platforms \cite{bryant2020webassembly}. 
Because of WASI, \wasm evolves further web browsers also to be part of edge-cloud computing platforms \cite{9640153, wen2020wasmachine}
WASI standarized a POSIX protocol to execute Wasm directly in the operating system. 
To give an example of the importance of this evolution of \wasm, let us use the exact words of Solomon Hykes, the former CEO of docker: 

\vspace{0.5cm}

\begin{minipage}{0.8\linewidth}
\say{
        \textit{If WASM+WASI existed in 2008, we wouldn't have needed to created Docker. That's how important it is. Webassembly on the server is the future of computing. A standardized system interface was the missing link. Let's hope WASI is up to the task!}\footnote{\url{https://twitter.com/solomonstre/status/1111004913222324225}}
}
\end{minipage}
% State of the art for Wasm

\section{Software Monoculture}

% Monoculture
Web browsers and JavaScript have nearly three decades of development.
Since then, web browsers have grown, nearly reaching 30 different implementations. 
Nevertheless, only Firefox, Chrome, Safari, and Edge dominate the presence on user computers.
This means that, for 5 arbitrary computers in a world of millions, at least two of them use the same web browser.
This highlight a software monoculture problem.
On the other hand, nowadays, the serving of web pages, including JavaScript and WebAssembly code, is centralized and served through main sources.
Therefore, millions of computers are executing the same code given the exact web browser implementation around the world.
Vulnerabilities make an enormous impact on user computers because of this.
The software monoculture problem escalates if we consider the edge-cloud computing platforms and how they are adopting Wasm to provide services, as we previously mentioned.
One might think that the solution is to adopt more web browser and interpreters implementations. 
However, this is virtually impossible as 4 web browsers dominate the market, thus, a solution in this address is doomed to fail. 
Another solution is to provide different JavaScript or WebAssembly codes as soon as they are requested from the internet. 
For example, a different source code, yet equivalent, can be provided when a web page is served. 
Consequently, millions of computers would execute different codes even though they use the same web browser.
This strategy is called Software Diversification.
% Monoculture and diversification motivation, 

\section{Software Diversification}

Software Diversification is the process of finding, creating, and deploying program variants for a given original program \cite{okhravi2013survey} for the sake of security.
Cohen \etal \cite{cohen1993operating} and Forrest \etal \cite{595185} pioneered this field by proposing software diversification through code transformations. 
They propose to produce variants of programs while preserving their functionalities to not be vulnerable.
Since then, transformations aiming at reducing the predictability of observable behavior of programs have been proposed. For example, works on this address proposed to diversify programs control flow \cite{davi2015isomeron}, instruction set \cite{barrantes2003randomized}, or the system calls they use \cite{Chew02mitigatingbuffer}. 
Several of these transformations can be combined to produce less predictable variants.
Previous works on software diversification demonstrated the removal of vulnerabilities, but remarkably in all cases, it can be used as a preemptive solution.
For example, if a vulnerability is present in one program variant, discovering and disseminating it will not affect other variants.

Moreover, software diversification can stress execution hosts since each program variant executes a different part of the system. For example, during the implementation of our approaches, a CVE \cite{CVE} was discovered in the compiler used by Fastly to provide edge-cloud computing.
The CVE was discovered by deploying and executing one program variant created with our software diversification solution.
The early discovery of this CVE prevented the exploitation of the whole platform.


Software diversification has been widely researched, not being the case for JavaScript and \wasm.
In this field, only Romano \etal \cite{wobfuscator} proposed the intermixing JavaScript and Wasm function calls to provide obfuscation against code analysis. 
In the case of JavaScript, it has been less researched because software diversification solutions need to deal with the challenging properties of the language.
On the one hand, the JavaScript engines perform Just-In-Time compilation, making software diversification unpredictable and, in most cases, not preserved \cite{STRAC}.
On the other hand, the dynamic properties of the language and its lack of abstraction models for the memory and the stack make it nearly impossible to apply traditional software transformations.
Besides, software diversification usually comes with an overhead trade-off not desired for JavaScript. 
In the case of \wasm no software diversification solution has been proposed, primarily due to its novelty.






\section{Artificial Software Diversification for \wasm}


WebAssembly's simplicity allows us to port code transformations proposed in previous works as a preemptive software diversification solution.
We propose a novel approach to provide artificial software diversification for \wasm.
In this thesis, we focus on \wasm because two main reasons. First,
despite being designed for sandboxing and secure execution, it is not exempt from vulnerabilities \cite{WebAssemblySecurity}.
For example, \wasm engines are vulnerable to speculative execution \cite{Narayan2021Swivel}, and C/C++ source code vulnerabilities might be ported to Wasm binaries \cite{DeRoover2022}.  
Remarkably, several approaches to harden \wasm recently appeared \cite{johnson2021}, still, the adoption of proposed defenses are not implemented in time as new vulnerabilities are discovered.
Second, \wasm has a growing adoption in server-side execution and edge-cloud computing platforms.
This latter opens the door for further vulnerabilities outside web browsers

\section{Research questions}
\label{intro:definition:rq}

Three main research questions conduct our work.
In this section, we present them. 
Our research questions are formulated by merging our publications and experiences during the creation of Software Diversification for WebAssembly. 


\begin{enumerate}[label=\subscript{RQ}{{\arabic*}}]
    \item \textbf{\rqone}\\
    With this research question, we quantitatively assess the static differences between program variants created by our approach. We answer this question at the population level, where a program population is the collection of one original program and its generated variants. We aim to investigate the code properties that increases(or diminishes) generated diversification at population level. 

    \item \textbf{\rqtwo} \\
    With this research question, we complement $RQ_1$. We aim to investigate the impact on execution traces and execution times of the generated program variants.

    \item \textbf{\rqthree} \\
    %\todo{Intro motiv}
    With this research question, we aim to investigate the impact of Software Diversification for WebAssembly in an emerging technology, edge-cloud computing. We evaluate the impact of a novel multivariant execution approach on real-world WebAssembly programs in a world-wide scale experiment.
    
    
\end{enumerate}


\renewcommand{\rqone}{$RQ_1$. To what extent can we artifically generate program variants for WebAssembly?}

\renewcommand{\rqtwo}{$RQ_2$. To what extent are the generated variants dynamically different?}
\renewcommand{\rqthree}{$RQ_3$. To what extent do the artificial variants exhibit different execution times on edge-cloud platforms?}

\section{Contributions}

This thesis contributes through four milestones. First, as a \emph{theoretical contribution}, we summarize the code transformations used to generate software diversification through an exhaustive literature review artificially. Consequently, we highlight the lack of diversification techniques for WebAssembly.
Second, as a \emph{technical contribution}, we provide two tools, CROW \cite{CROW} and MEWE \cite{MEWE}. CROW creates 
Wasm program variants by retargeting a superoptimizer \cite{Sasnauskas2017Souper:Superoptimizer}.
MEWE merges several Wasm program variants in a multivariant execution schema \cite{okhravi2013survey}.
In addition, we summarize the main challenges faced during their implementation, such as i) program properties that make it prone to generate more variants and ii) program properties that make the observable behavior of variants different. 
Besides, we discuss the incorporation of \emph{constant inferring} as a new transformation. 
Third, we propose a \emph{methodology} to quantitatively evaluate the impact of our tools, assessing the creation of artificial software diversification for WebAssembly. 
Fourth and final, we \emph{empirically demonstrate} the impact of our technique by evaluating the static and dynamic behavior of the generated diversification.
Our results show that creating software diversification is feasible for \wasm. 
Moreover, the created diversification remarkably affects the observable behavior of program variants in web browsers and standalone interpreters.

\section{Publications}

This work is based on the following publications:

\begin{enumerate}[label=\subscript{P}{{\arabic*}}]
    \item Superoptimization of WebAssembly Bytecode \cite{WasmSuperoptimizer}\\
    {\small\textbf{Javier Cabrera-Arteaga}, Shrinish Donde, Jian Gu, Orestis Floros, Lucas Satabin, Benoit Baudry, Martin Monperrus}\\
        \emph{Programming 2020, MoreVMs'20}
        %{\small
        %\textbf{Abstract:} Motivated by the fast adoption of WebAssembly, we propose the first functional pipeline to support the superoptimization of WebAssembly bytecode. Our pipeline works over LLVM and Souper. We evaluate our superoptimization pipeline with 12 programs from the Rosetta code project. Our pipeline improves the code section size of 8 out of 12 programs. We discuss the challenges faced in superoptimization of WebAssembly with two case studies.}
    \item CROW: Code Diversification for WebAssembly \cite{CROW}\\
    {\small\textbf{Javier Cabrera-Arteaga}, Orestis Floros, Oscar Vera-PÃ©rez, Benoit Baudry, Martin Monperrus}\\
    \emph{NDSS 2021, MADWeb}
    %{\small
    %\textbf{Abstract:} The adoption of WebAssembly has rapidly increased in the last few years as it provides a fast and safe model for program execution. However, WebAssembly is not exempt from vulnerabilities that could be exploited by side channels attacks. This class of vulnerabilities that can be addressed by code diversification. In this paper, we present the first fully automated workflow for the diversification of WebAssembly binaries. We present CROW, an open-source tool implementing this workflow. We evaluate CROW's capabilities on 303 C programs and study its use on a real-life security-sensitive program: libsodium, a cryptographic library. Overall, CROW is able to generate diverse variants for 239 out of 303,(79\%) small programs. Furthermore, our experiments show that our approach and tool is able to successfully diversify off-the-shelf cryptographic software (libsodium).}
    \item Multi-Variant Execution at the Edge \cite{MEWE}\\
    {\small\textbf{Javier Cabrera-Arteaga}, Pierre Laperdrix, Martin Monperrus, Benoit Baudry}\\
    \emph{Under review}
    %{\small
    %\textbf{Abstract:} Edge-cloud computing offloads parts of the computations that traditionally occurs in the cloud to edge nodes,e.g., CDN servers, in order to get closer to the users and reduce latency. To improve performance even further, WebAssembly is increasingly used in this context. Edge-cloud computing providers, such as Fastly or Cloudflare, let their clients deploy stateless services in the form of WebAssembly binaries, which are then translated to machine code and sandboxed for a safe execution at the edge.
    %In this context, we propose a technique that (i) automatically diversifies WebAssembly binaries that are deployed to the edge and (ii) randomizes execution paths at runtime, turning the execution of the services into a moving target. Given a service tobe deployed at the edge, we automatically synthesize functionally equivalent variants for the functions that implement the service.All the variants are then wrapped into a single multivariant WebAssembly binary. When the service endpoint is executed,every time a function is invoked, one of its variants is randomly selected. We implement this technique in the MEWE tool and we validate it with 7 services for cryptography and QR encoding. MEWE generates multivariant binaries that embed hundreds of function variants. We execute the multivariant binaries on the worldwide edge platform provided by Fastly. We show that,at runtime, the multivariant exhibit a remarkable diversity ofexecution traces, across the whole edge platform. }
    \item Scalable Comparison of JavaScript V8 Bytecode Traces \cite{STRAC}\\
    {\small\textbf{Javier Cabrera-Arteaga}, Martin Monperrus, Benoit Baudry}\\
    \emph{SPLASH 2019, VMIL}
\end{enumerate}

\pagebreak
\section*{Thesis layout}

This dissertation is organized in five chapters including this. \autoref{chapter:sota} presents background and the state of the art for WebAssembly and Artificial Software Diversification.
\autoref{chapter:technical} describes our technical contributions, faced challenges and engineering decisions carried out to implement our artifacts. \autoref{chapter:method} describes the methodology followed to answer the three main
research questions driving this thesis. \autoref{chapter:results} details the main results of this work. \autoref{chapter:conclude} concludes and discuss future work. 
In addition, this dissertation contains the collection of research papers previously mentioned in this chapter.