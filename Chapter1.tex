\chapter{Introduction}
\label{chapter:intro}

\chapterprecishere{"\input{quotes/cinderella1.tex}"\par\raggedleft--- {\small\textup{MR. Cox} \textbf{1893}, Cinderella: Three hundred and forty-five variants \cite{cox1893cinderella}}}

% Birth
The Web Consortium (W3C) standarized bytecode for the web environment with the \wasm (Wasm) language in 2015. 
% Evolution, history and importance
Wasm allows web browsers to execute existing programs or libraries written in other languages, such as C/C++ and Rust.
Beyond web environments, \wasm evolves to be part of Edge-Cloud computing platforms \cite{9640153, wen2020wasmachine}. 
% Problems
Despite being designed for sandboxing and secure execution, it is not exempt from vulnerabilities \cite{WebAssemblySecurity}.
% Problem instantiation
For example, \wasm engines are vulnerable to speculative execution \cite{Narayan2021Swivel}, and C/C++ source code vulnerabilities might be ported to Wasm binaries \cite{DeRoover2022}.  

% MTD and the need for variants
One strategy to hide such vulnerabilities is to move them in time as a preemptive solution.
The goal is to make potential vulnerabilities available only in a time window. This makes potential attackers not hit what they cannot see.  
This strategy is usually called Moving Target Defense (MTD) \cite{MTDNationalCyberLaep, okhravi2013survey}. 
MTD for software is a collection of techniques that aim to improve the security of a system by constantly rotating its vulnerable programs from one variant to another. 
A program variant should be different from the original program but functionally equivalent to it.
By rotating the deployment and execution between the program variants, a potential attacker needs more efforts to perform the same attack for all variants \cite{sengupta}.
Thus, one premise for effectively implementing MTD for a given program is the need for the program variants.


% SD
In MTD, Software Diversification is the process of finding, creating, and deploying program variants.
Usually, program variants could be found in the wild in a phenomenon called natural diversity \cite{Harrand1650630}. In the case of WebAssembly, since it is a novel technology, there is no natural diversity. Thus, effective MTD cannot be implemented due to the lack of program variants.
This work proposes to create program variants for \wasm artificially. 
Therefore, we aim to generate artificial software diversification for WebAssembly.
To reach such a goal, we answer three research questions enunciated in the following.

%Compared to the work of Harrand \etal \cite{Harrand1650630}, in WebAssembly, we cannot use preexisting and different programs to provide software diversification. In fact, according to the work of Hilbig \etal \cite{Hilbig2021AnES}, they filter out half of internet available \wasm corpus due to that filtered programs where artifically provided by one of our tools. 


%Due to the current evolution of the \wasm roadmap, every time is harder to find vulnerabilities and keep up to the date the engines. 

% - Engines are not yet mature and are prone to errors, stress the case of the CVE

% Software diversification as a preemptive solution and as a Moving Target Defense strategy


% Lack of Natural Software Diversification and a high presence of monoculture
% - the birth of a new package manager and the translation of preexisting ones such as cargo and the LLVM itself.

% Our solution is to artificially diversify



%\section{Thesis Statement}

%\section{Motivation}

%\subsection{Why variants ?}

\section{Research questions}
\label{intro:definition:rq}

In this section, we present our three research questions. Our research questions are formulated by merging our publications and experiences during the creation of Software Diversification for WebAssembly. 

\begin{enumerate}[label=\subscript{RQ}{{\arabic*}}]
    \item \textbf{\rqone}\\
    With this research question, we quantitatively assess the static differences between program variants created by our approach. We answer this question at the population level, where a program population is the collection of one original program and its generated variants. We aim to investigate the code properties that increases(or diminishes) generated diversification at population level. 

    \item \textbf{\rqtwo} \\
    With this research question, we complement $RQ_1$. We aim to investigate the impact on execution traces and execution times of the generated program variants.

    \item \textbf{\rqthree} \\
    %\todo{Intro motiv}
    With this research question, we aim to investigate the impact of Software Diversification for WebAssembly in an emerging technology, Edge-Cloud computing. We evaluate the impact of a novel multivariant execution approach on real-world WebAssembly programs in a world-wide scale experiment.
    
    
\end{enumerate}


\renewcommand{\rqone}{$RQ_1$. To what extent can we artifically generate program variants for WebAssembly?}

\renewcommand{\rqtwo}{$RQ_2$. To what extent are the generated variants dynamically different?}
\renewcommand{\rqthree}{$RQ_3$. To what extent do the artificial variants exhibit different execution times on Edge-Cloud platforms?}

\section{Contributions}

This thesis contributes through four milestones. First, as a theoretical contribution, we summarize the code transformations used to artifically generate software diversification through an exhaustive literature review. Consequently, we highlight the lack of diversification techniques for WebAssembly.  Second, as a technical contribution, we provide two tools, CROW \cite{CROW} and MEWE \cite{MEWE}. Besides, we summarize the main challenges faced during their implementation. In addition, we discuss the incorporation of \emph{constant inferring} as a new transformation. Third, we propose a methodology to quantitatively evaluate the impact of our tools, assessing the creation of artificial software diversification for WebAssembly. Fourth and final, we empirically demonstrate the impact of our technique by evaluating the static and dynamic behavior of the generated diversification.

\pagebreak
\section{Publications}

This work is based on the following publications:

\begin{enumerate}[label=\subscript{P}{{\arabic*}}]
    \item Superoptimization of WebAssembly Bytecode \cite{WasmSuperoptimizer}\\
    {\small\textbf{Javier Cabrera-Arteaga}, Shrinish Donde, Jian Gu, Orestis Floros, Lucas Satabin, Benoit Baudry, Martin Monperrus}\\
        \emph{Programming 2020, MoreVMs'20}\\
        %{\small
        %\textbf{Abstract:} Motivated by the fast adoption of WebAssembly, we propose the first functional pipeline to support the superoptimization of WebAssembly bytecode. Our pipeline works over LLVM and Souper. We evaluate our superoptimization pipeline with 12 programs from the Rosetta code project. Our pipeline improves the code section size of 8 out of 12 programs. We discuss the challenges faced in superoptimization of WebAssembly with two case studies.}
    \item CROW: Code Diversification for WebAssembly \cite{CROW}\\
    {\small\textbf{Javier Cabrera-Arteaga}, Orestis Floros, Oscar Vera-PÃ©rez, Benoit Baudry, Martin Monperrus}\\
    \emph{NDSS 2021, MADWeb}\\
    %{\small
    %\textbf{Abstract:} The adoption of WebAssembly has rapidly increased in the last few years as it provides a fast and safe model for program execution. However, WebAssembly is not exempt from vulnerabilities that could be exploited by side channels attacks. This class of vulnerabilities that can be addressed by code diversification. In this paper, we present the first fully automated workflow for the diversification of WebAssembly binaries. We present CROW, an open-source tool implementing this workflow. We evaluate CROW's capabilities on 303 C programs and study its use on a real-life security-sensitive program: libsodium, a cryptographic library. Overall, CROW is able to generate diverse variants for 239 out of 303,(79\%) small programs. Furthermore, our experiments show that our approach and tool is able to successfully diversify off-the-shelf cryptographic software (libsodium).}
    \item Multi-Variant Execution at the Edge \cite{MEWE}\\
    {\small\textbf{Javier Cabrera-Arteaga}, Pierre Laperdrix, Martin Monperrus, Benoit Baudry}\\
    \emph{Under review}\\
    %{\small
    %\textbf{Abstract:} Edge-cloud computing offloads parts of the computations that traditionally occurs in the cloud to edge nodes,e.g., CDN servers, in order to get closer to the users and reduce latency. To improve performance even further, WebAssembly is increasingly used in this context. Edge-cloud computing providers, such as Fastly or Cloudflare, let their clients deploy stateless services in the form of WebAssembly binaries, which are then translated to machine code and sandboxed for a safe execution at the edge.
    %In this context, we propose a technique that (i) automatically diversifies WebAssembly binaries that are deployed to the edge and (ii) randomizes execution paths at runtime, turning the execution of the services into a moving target. Given a service tobe deployed at the edge, we automatically synthesize functionally equivalent variants for the functions that implement the service.All the variants are then wrapped into a single multivariant WebAssembly binary. When the service endpoint is executed,every time a function is invoked, one of its variants is randomly selected. We implement this technique in the MEWE tool and we validate it with 7 services for cryptography and QR encoding. MEWE generates multivariant binaries that embed hundreds of function variants. We execute the multivariant binaries on the worldwide edge platform provided by Fastly. We show that,at runtime, the multivariant exhibit a remarkable diversity ofexecution traces, across the whole edge platform. }
    \item Scalable Comparison of JavaScript V8 Bytecode Traces \cite{STRAC}\\
    {\small\textbf{Javier Cabrera-Arteaga}, Martin Monperrus, Benoit Baudry}\\
    \emph{SPLASH 2019, VMIL}\\
\end{enumerate}

\section*{Thesis layout}

This dissertation is organized in five chapters including this. \autoref{chapter:sota} presents background and the state of the art for WebAssembly and Artificial Software Diversification.
\autoref{chapter:technical} describes our technical contributions, faced challenges and engineering decisions carried out to implement our artifacts. \autoref{chapter:method} describes the methodology followed to answer the three main
research questions driving this thesis. \autoref{chapter:results} details the main results of this work. \autoref{chapter:conclude} concludes and discuss future work. 
In addition, this dissertation contains the collection of research papers previously mentioned in this chapter.