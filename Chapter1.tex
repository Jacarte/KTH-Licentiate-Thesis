\chapter{Introduction}

\chapterprecishere{"\input{quotes/cinderella1.tex}"\par\raggedleft--- {\small\textup{MR. Cox} \textbf{1893}, Cinderella: Three hundred and forty-five variants \cite{cox1893cinderella}}}


%\todo{Two references per paragraph}

%\todo{Base paragraph by the papers}

% WebAssembly as new technology
The W3C standardized bytecode for the web environment with \wasm (Wasm) language in 2015, opening up the browser clients ecosystem to a broader collection of programming languages. Wasm allows the use of existing programs or libraries that are written in other languages, such as C and Rust, to be run in the web browser environment. It also claims that is better than JavaScript to perform compute-intensive tasks \cite{Haas_2017}. 
Further browser environments, it evolves to be a new technology for Edge-Cloud computing platforms, resulting in bandwidth saving, execution improvement, and process-on-demand fast spawning \cite{9640153, wen2020wasmachine}. However, since it a relatively new technology, it is not exempt of vulnerabilities.

% Moving target defense
Software bugs are inherited in any software development process, including both, the \wasm engines and the source code that generates the Wasm binaries. One temporary solution to deal with bugs is to move them in time as a preemptive solution, the bug is only available in a time window. This strategy is usually called Moving Target Defense (MTD). Moving Target Defense for software was first proposed as a collection of techniques that aim to improve the security of a system by constantly moving its vulnerable components \cite{MTDNationalCyberLaep, okhravi2013survey}. Usually, MTD techniques revolve around changing systems to reduce vulnerable surfaces. This increases uncertainty for attackers and makes their attacks more difficult. Ultimately, potential attackers cannot hit what they cannot see. MTD can be implemented in different ways, including via Software Diversification. 
%In the case of \autoref{usage:n-version}, this usage lacks of the time dimension, \ie program variants are not changed from time to time. 

Software Diversification has shown to be a good preemptive technique \citationneeded, preventing exploitation of vulnerabilities or hardening harmful analysis of programs. In one of our experiments, a CVE was discovered inside the Lucet compiler, showing new vulnerabilities are still present in battle-tested engines. This CVE was discovered thanks to our Software Diversification strategies and was solved even before it was public. 


%Due to the current evolution of the \wasm roadmap, every time is harder to find vulnerabilities and keep up to the date the engines. 

% - Engines are not yet mature and are prone to errors, stress the case of the CVE

% Software diversification as a preemptive solution and as a Moving Target Defense strategy


% Lack of Natural Software Diversification and a high presence of monoculture
% - the birth of a new package manager and the translation of preexisting ones such as cargo and the LLVM itself.
The low presence of defenses implementations for \wasm and the pace of their practical adoption motivate our work on Software Diversification as a preemptive technique that can help against known and yet unknown vulnerabilities.
Another motivation for this work is that \wasm lacks of natural diversity, \ie for a single \wasm program in the wild, it has a lower presence of versions. Moreover, compared to the work of Harrand \etal \cite{Harrand1650630}, in WebAssembly, we cannot use preexisting and different programs to provide diversification. In fact, according to the work of Hilbig \etal \cite{Hilbig2021AnES}, they filter out half of internet available \wasm corpus due to that filtered programs where artifically provided by one of our tools. 

% Our solution is to artificially diversify



%\section{Thesis Statement}

%\section{Motivation}

%\subsection{Why variants ?}

\section{Research questions}
\label{intro:definition:rq}

In this section, we present our three research questions. Our research questions are formulated by merging our publications and experiences during the creation of Software Diversification for WebAssembly. 

\begin{enumerate}[label=\subscript{RQ}{{\arabic*}}]
    \item \textbf{\rqone}\\
    With this research question, we quantitatively assess the static differences between program variants created by our approach. We answer this question at the population level, where a program population is the collection of one original program and its generated variants. We aim to investigate the code properties that increases(or diminishes) generated diversification at population level. 

    \item \textbf{\rqtwo} \\
    With this research question, we complement $RQ_1$. We aim to investigate the impact on execution traces and execution times of the generated program variants.

    \item \textbf{\rqthree} \\
    %\todo{Intro motiv}
    With this research question, we aim to investigate the impact of Software Diversification for WebAssembly in an emerging technology, Edge-Cloud computing. We evaluate the impact of a novel multivariant execution approach on real-world WebAssembly programs in a world-wide scale experiment.
    
    
\end{enumerate}


\renewcommand{\rqone}{$RQ_1$.To what extent can we artifically generate program variants for WebAssembly?}

\renewcommand{\rqtwo}{$RQ_2$.To what extent are the generated variants dynamically different?}
\renewcommand{\rqthree}{$RQ_3$.To what extent do the artificial variants exhibit different execution times on Edge-Cloud platforms?}

\section{Contributions}

The contributions of this thesis are:

\begin{enumerate}[label=\subscript{C}{{\arabic*}}]
    \item Technical contribution: Along with this work, we contribute with several software artifacts, and summarize the main challenges faced during their implementation.
    
    \item Methodological contribution: We propose a quantitative methodology to evaluate the impact of our artifacts, assessing the creation of Artificial Software Diversification for WebAssembly.  
    
    \item Experimental contribution: We contribute to generate Artificial Software Diversification for WebAssembly. We empirically demonstrate the impact on static and dynamic behavior for our diversification technique.
    
    \item Theoretical contribution: We summarize the code transformations used to artifically generate software diversification through an exhaustive literature review, and highlight the lack of diversification techniques for WebAssembly. In addition, we discuss the incorporation of \emph{Constant Inferring} as a new diversification technique.
\end{enumerate}

\section{Publications}

This work is based on the following publications:

\begin{enumerate}[label=\subscript{P}{{\arabic*}}]
    \item Superoptimization of WebAssembly Bytecode \cite{WasmSuperoptimizer}\\
    {\small\textbf{Javier Cabrera-Arteaga}, Shrinish Donde, Jian Gu, Orestis Floros, Lucas Satabin, Benoit Baudry, Martin Monperrus}\\
        \emph{Programming 2020, MoreVMs'20}\\
        {\small
        \textbf{Abstract:} Motivated by the fast adoption of WebAssembly, we propose the first functional pipeline to support the superoptimization of WebAssembly bytecode. Our pipeline works over LLVM and Souper. We evaluate our superoptimization pipeline with 12 programs from the Rosetta code project. Our pipeline improves the code section size of 8 out of 12 programs. We discuss the challenges faced in superoptimization of WebAssembly with two case studies.}
    \item CROW: Code Diversification for WebAssembly \cite{CROW}\\
    {\small\textbf{Javier Cabrera-Arteaga}, Orestis Floros, Oscar Vera-PÃ©rez, Benoit Baudry, Martin Monperrus}\\
    \emph{NDSS 2021, MADWeb}\\
    {\small
    \textbf{Abstract:} The adoption of WebAssembly has rapidly increased in the last few years as it provides a fast and safe model for program execution. However, WebAssembly is not exempt from vulnerabilities that could be exploited by side channels attacks. This class of vulnerabilities that can be addressed by code diversification. In this paper, we present the first fully automated workflow for the diversification of WebAssembly binaries. We present CROW, an open-source tool implementing this workflow. We evaluate CROW's capabilities on 303 C programs and study its use on a real-life security-sensitive program: libsodium, a cryptographic library. Overall, CROW is able to generate diverse variants for 239 out of 303,(79\%) small programs. Furthermore, our experiments show that our approach and tool is able to successfully diversify off-the-shelf cryptographic software (libsodium).}
    \item Multi-Variant Execution at the Edge \cite{MEWE}\\
    {\small\textbf{Javier Cabrera-Arteaga}, Pierre Laperdrix, Martin Monperrus, Benoit Baudry}\\
    \emph{Under review}\\
    {\small
    \textbf{Abstract:} Edge-cloud computing offloads parts of the computations that traditionally occurs in the cloud to edge nodes,e.g., CDN servers, in order to get closer to the users and reduce latency. To improve performance even further, WebAssembly is increasingly used in this context. Edge-cloud computing providers, such as Fastly or Cloudflare, let their clients deploy stateless services in the form of WebAssembly binaries, which are then translated to machine code and sandboxed for a safe execution at the edge.
    In this context, we propose a technique that (i) automatically diversifies WebAssembly binaries that are deployed to the edge and (ii) randomizes execution paths at runtime, turning the execution of the services into a moving target. Given a service tobe deployed at the edge, we automatically synthesize functionally equivalent variants for the functions that implement the service.All the variants are then wrapped into a single multivariant WebAssembly binary. When the service endpoint is executed,every time a function is invoked, one of its variants is randomly selected. We implement this technique in the MEWE tool and we validate it with 7 services for cryptography and QR encoding. MEWE generates multivariant binaries that embed hundreds of function variants. We execute the multivariant binaries on the worldwide edge platform provided by Fastly. We show that,at runtime, the multivariant exhibit a remarkable diversity ofexecution traces, across the whole edge platform. }
\end{enumerate}

% \subsection*{Origin of contributions ?}
\subsection*{Other publications and talks}

\begin{enumerate}
    \item Scalable Comparison of JavaScript V8 Bytecode Traces \cite{STRAC}\\
    {\small\textbf{Javier Cabrera-Arteaga}, Martin Monperrus, Benoit Baudry}\\
    \emph{SPLASH 2019, VMIL}\\
    {\small
    \textbf{Abstract:} 
    The comparison and alignment of runtime traces are essential, e.g., for semantic analysis or debugging. However, naive sequence alignment algorithms cannot address the needs of the modern web: (i) the bytecode generation process of V8 is not deterministic; (ii) bytecode traces are large.
    We present STRAC, a scalable and extensible tool tailored to compare bytecode traces generated by the V8 JavaScript engine. Given two V8 bytecode traces and a distance function between trace events, STRAC computes and provides the best alignment. The key insight is to split access between memory and disk. STRAC can identify semantically equivalent web pages and is capable of processing huge V8 bytecode traces whose order of magnitude matches today's web like https://2019.splashcon.org, which generates approx. 150k of V8 bytecode instructions.
     }
    \item (Talk) Wasm-mutate: Fuzzing WebAssembly Compilers with E-Graphs\\
    \textbf{Javier Cabrera-Arteaga}, Nicholas Fitzgerald, Martin Monperrus, Benoit Baudry\\
    \emph{PLDI 2022, EGRAPHs}\\
\end{enumerate}

\section*{Thesis layout}

This dissertation is organized in five chapters including this. \autoref{chapter:sota} presents background and the state of the art for WebAssembly and Artificial Software Diversification.
\autoref{chapter:technical} describes our technical contributions, faced challenges and engineering decisions carried out to implement our artifacts. \autoref{chapter:method} describes the methodology followed to answer the three main
research questions driving this thesis. \autoref{chapter:results} details the main results of this work. \autoref{chapter:conclude} concludes and discuss future work. 
In addition, this dissertation contains the collection of research papers previously mentioned in this chapter.