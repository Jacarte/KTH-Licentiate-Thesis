\chapter{Conclusion and Future Work}
\label{chapter:conclude}

\wasm has become a new technology for web browsers and standalone engines such as the ones used in edge-cloud platforms. \wasm is designed with security and sandboxing premises, yet, is still vulnerable.
Besides, since it is a relatively new technology, new vulnerabilities appear in the wild faster than the adoption of patches and defenses.
As a widely studied field, software diversification could be a solution for known and yet-unknown vulnerabilities. Yet, there is no research on this field for \wasm.

We propose an automatic approach to generate software diversification for \wasm in this work. 
In addition, we provide complementary implementation for our approaches, including a generic LLVM superdiversifier that potentially extends our ideas to other programming languages.
We empirically demonstrate the impact of our approach by providing Randomization and Multivariant Execution (MVE) for \wasm.
For this, we provide two tools, CROW and MEWE. CROW completely automatizes the process by using a superdiversifier. Besides, MEWE provides execution path randomization for an MVE.
This chapter is organized into two sections. 
In \autoref{conclusions:summary}, we summarize the main results we found by answering our research questions enunciated in \autoref{chapter:intro}.
Finally, \autoref{future_work} describes potential future work that could extend this dissertation.

\section{Summary of the results}
\label{conclusions:summary}

We enunciate the three research questions in \autoref{chapter:intro}. 
With the first research question, we investigate the static properties of the software diversification for \wasm generated by our approaches. 
We answer our first research question by creating near 1 million program variants for \pypy{303 + \libsodiumfunctions + \qrcodefunctions} original programs. 
With CROW, we create program variants for the 11.78\% of the programs in our corpora.
The generated variants are semantically equivalent to their respective original programs.
We study the properties of the generated variants at the level of generated programs' population.
Thus, we identify the challenges that attempt against the generation of unique program variants.
Besides, we highlight the code properties that offer numerous program variants. 

Complementing our first research question, we evaluate the dynamic properties of the program variants generated to answer our first research question.
We execute each of the 303 original programs and its generated variants for the \corpusrosetta.
For each execution, we collect their execution trace and their execution times.
We demonstrate that the \wasm variants generated by CROW offer remarkably different execution traces.
Similarly, the execution times are different between each program and its variants.
For the $71\%$ of the diversified programs, at least one variant has an execution-time distribution different from the original program's execution time distribution.
Moreover, CROW generates both faster and slower variants.
Nevertheless, we highlighted the importance of dynamic analysis for software diversification. 

Our last and third research question evaluates the impact of providing a worldwide MVE for \wasm.
We use MEWE to build multivariant binaries for the program variants generated for \corpussodium and \corpusqrcode corpora.
We collect their execution times by deploying the generated multivariant binaries in an edge-cloud platform.
The addition of runtime path randomization to multivariant binaries provides significant differences between the execution of the original binary and the multivariant binary.
The observed differences lead us to conclude that no specific variant can be inferred from studying the execution time of the multivariant binaries. Therefore, attacks that rely on measuring precise execution times are more challenging to conduct.


Overall, these results show that our approaches can provide an automated end-to-end solution for diversifying \wasm programs. 
Our approaches harden observable properties commonly used to conduct attacks, such as static code analysis, execution traces, and execution time.
Therefore, our approaches harden \wasm against unknown and yet-unknown vulnerabilities.


\section{Future work}
\label{future_work}

There are many directions in which software diversification for \wasm could be researched further.
In this section, we describe three possible orthogonal lines of work.

\\
\\

\textbf{CROW and MEWE:} Along with this dissertation, we highlighted challenges and limitations. In all cases, we proposed solutions, yet, some of them could be explored more in-depth.
As we mentioned in \autoref{results:rq1} our solution provides program variants but remarkably lower unique variants as a consequence of the replacement combining process of CROW (\autoref{section:crow}). 
Techniques relying on intelligent heuristics could help increase the generation of unique variants by early discarding unsound combinations.
On the other hand, constant inferring does not always finish in a successful replacement due to the CROW's obliviousness to some computation models, such as memory operations. 
A solution could also be to use heuristics to select which part of the code is more probable to become a constant inferred assignment.
On the other hand, MEWE introduces overhead during the execution of the multivariant binaries.
We identified the dispatcher calling the function variants as the main reason.
Each time a new variant executes, it involves the introduction of a new function call through the dispatcher.
Our variants are artificially created. Thus, their bodies could be directly inlined in the dispatcher's body.
This means that we can reduce the number of function calls by inlining the variant.
Nevertheless, a deeper study on the security consequences is needed.
\\

\textbf{Obfuscation, data augmentation and malware classification:}
% Obfuscation
Wasm is extensibly used for cryptocurrency mining. 
Sometimes the crypto-mining is done without the consent of users, creating what is called crypto-malwares \cite{Hilbig2021AnES}.
Antivirus software could detect them. 
However, a recent work \cite{10.1145/3507657.3528560} shows that malware classifiers could be bypassed with the correct obfuscation technique.
Our diversification approach could be used to increase resilience in malware classifiers by training them with augmented datasets on semantically equivalent malwares.
On the other hand, superoptimization can be used to build a canonical code representation of a variant's population.
Therefore, if a classifier uses a canonical representation, then malware obfuscation could be mitigated.
\\

\textbf{Better fuzzing:}
Fuzzers have become one of the most used techniques for automated testing \cite{zalewski2017american}, and compilers are not the exception.
Fastly uses this technique to test their compiler, Lucet.
Their fuzzing technique randomly creates different Wasm binaries and passes them to the compiler. If the compiler crashes, a bug report is created and fixed later.
Our approaches created one binary that crashed their compiler\cite{CVE}, after they had no bug for months.
Therefore, our code transformations outperform their code generation for testing. 
This highlighted the need for better strategies for stressing compilers, interpreters, and validators for \wasm.
CROW and MEWE might be used for fuzzing, preventing vulnerabilities, and providing better testing of systems.


