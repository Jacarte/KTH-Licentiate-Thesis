
\section{\rqone}
\label{results:rq1}

\newcommand{\diversifiedsodium}{85}
\newcommand{\diversifiedqrcode}{32}
\newcommand{\libsodiumpopulation}{4272}
\newcommand{\qrpopulation}{6369}


\newcommand{\allmewediversified}{\diversifiedsodium + \diversifiedqrcode}
\newcommand{\allmewepopulation}{\libpopulation + \qrpopulation}

As we describe in \autoref{rq1:method}, our first research question aims to answer how to generate \wasm program variants. \todo{Motivate} We pass each function of the corpora listed in \autoref{table:corpora} to CROW, and we collect how many variants CROW generates for each function.
This section is organized as follows. First we present the general results for \emph{Population size}(\autoref{metric:md5sum}) for each corpus. 
Second, we discuss the challenges and limitations in program variants generation. Finally, we illustrate the most common code transformations performed by our approach and answer RQ1.

\subsection*{Program's populations}

We summarize the results in \autoref{table:crow:general_results}.
The table is illustrates the Corpus name, the number of functions to diversify, the number of successfully diversified functions (functions with at least one artificially created variant) along with the percentage of successfully diversified functions, the cumulative number of variants taking into account all programs in the corpus and the relation between the increased population size and the original number of functions in the corpus.

% General results on the number of diversified functions per corpus
We produce at least one unique program variant for $239/303{}$ single function programs for \corpusrosetta with one hour for a timeout. For the rest of the programs ($64/303{}$), the timeout is reached before CROW can find any valid variant. 
In the case of \corpussodium and \corpusqrcode, we produce variants for $\py{\diversifiedsodium}/\py{\libsodiumfunctions}$ and $\py{\diversifiedqrcode}/\py{\qrcodefunctions}$ functions respectively, with 5 minutes per function as timeout. The rest of the functions resulted in timeout before finding function variants or produce no variants. For all programs in all corpora, we achieve $356/3021$ successfully diversified functions, for a $11.78\%$.
% General growing factor
As the four and fifth columns show, the number of artifically created variants increased the original population $4.15$ times, from $3021$ programs to $12547$.


\input{results/result_static_diversity.tex}


\subsection*{Challenges for automatic diversification}
\label{rq1:challenges}

We have observed a remarkable difference between the number of successfully diversified functions versus the number of failed-to-diversify functions (third column of \autoref{table:crow:general_results}). Our approach successfully diversified approx. 79 \%, \py{100*{\diversifiedsodium} / {\libsodiumfunctions}}\% and \py{100*{\diversifiedqrcode} / {\qrcodefunctions}}\% of the original functions for \corpusrosetta, \corpussodium and \corpusqrcode respectively. 

Setting up the timeout affects the capacity for diversification. A low timeout for exploration gives our approach more power to combine code replacements. We can appreciate this in the last column of the table, where for a lower number of diversified functions, we create, overall, more variants.

%Moreover, we look at the cases that yield a few variants per function. There is no direct correlation between the number of identified codes for replacement and the number of unique variants. Therefore, 

Apart from the timeout, we manually analyze programs searching for properties attempting to the generation of program variants using CROW.
We identify two main challenges for diversification.

\emph{1) Constant computation}  We have observed that our approach searches for a constant replacement for more than $45\%$ of the blocks of each function while constant values cannot be inferred. For instance, constant values cannot be inferred for memory load operations because our tool is oblivious to a memory model. 

\emph{2) Combination computation}  The overlap between code replacements, is a second factor that limits the number of unique variants. We can generate a high number of variants, but not all replacement combinations are necessarily unique.

%\todo{Add all the found examples here}


\subsection*{Properties for large diversification}

We manually analyzed the programs that yield more than 100 variants to study the critical properties of programs producing a high number of variants.
This reveals one key factor that favors many unique variants: the presence of bounded loops. In these cases, we synthesize variants for the loops by replacing them with a constant, if the constant inferring \cite{souper} is successful. Every time a loop constant is inferred, the loop body is replaced by a single instruction. This creates a new, statically different program. The number of variants grows exponentially if the function contains nested loops for which we can successfully infer constants. 

% 
\todo{Below is cryptic, take a look}
The before mentioned factor seems to be contradictory to the challenges mentioned in \autoref{rq1:challenges}. Constant inferring could generate program variants as it can attempt against their generation. In previous studies \citationneeded, the authors highlight that more than 40\% of code can be replaced with a constant. 

A second key factor for synthesizing many variants relates to the presence of arithmetic. The synthesis engine used by our approach, effectively replaces arithmetic instructions with equivalent instructions that lead to the same result. For example, we generate unique variants by replacing multiplications with additions or shift left instructions (\autoref{add:example}). Also, logical comparisons are replaced, inverting the operation and the operands (\autoref{cmp:examples}). Besides, our implementation can use overflow and underflow of integers to produce variants (\autoref{overflow:example}), using the intrinsics of the underlying computation model.

{
\begin{code}
    \footnotesize
    \lstdefinestyle{nccode}{
        numbers=none,
        firstnumber=2,
        stepnumber=1,
        numbersep=10pt,
        tabsize=4, 
        showspaces=false,
        breaklines=true, 
        showstringspaces=false,
        moredelim=**[is][\btHL]{`}{`},
        moredelim=**[is][{\btHL[fill=black!10]}]{`}{`},
        moredelim=**[is][{\btHL[fill=celadon!40]}]{!}{!}
    }

    \lstset{
        language=WAT,
        style=nccode,
        basicstyle=\footnotesize\ttfamily,
        columns=fullflexible,
        breaklines=true
    }
    \noindent\begin{minipage}[b]{0.32\linewidth}
        \captionof{lstlisting}{Diversification through arithmetic expression replacement.}\label{add:example}
        \noindent\begin{minipage}[t]{0.46\linewidth}
            \begin{lstlisting}
local.get 0
`i32.const 2`
`i32.mul`
            \end{lstlisting}
        \end{minipage}%
        \hfill\noindent\begin{minipage}[t]{0.46\linewidth}
            
            \begin{lstlisting}
local.get 0
!i32.const 1!
!i32.shl!
            \end{lstlisting}
        \end{minipage}
    \end{minipage}\hfill%
    \begin{minipage}[b]{0.31\linewidth}
        \captionof{lstlisting}{Diversification through inversion of comparison operations.}\label{cmp:examples}
        \begin{minipage}[t]{.46\linewidth}
            \begin{lstlisting}
`local.get 0`
`i32.const 10`
`i32.gt_s`
            \end{lstlisting}
        \end{minipage}\hfill\begin{minipage}[t]{.46\linewidth}
           
            \begin{lstlisting}
!i32.const 11!
!local.get 0!
!i32.le_s!
            \end{lstlisting}
        \end{minipage}%
        
        
    \end{minipage}\hfill\noindent
    \noindent\begin{minipage}[b]{0.32\linewidth}
        \captionof{lstlisting}{Diversification through overflow of integer operands.}\label{overflow:example}
        \noindent\begin{minipage}[t]{0.46\linewidth}
            \begin{lstlisting}
`i32.const 2`
i32.mul
\end{lstlisting}
        \end{minipage}%
        \hfill\noindent\begin{minipage}[t]{0.46\linewidth}
            
            \begin{lstlisting}
i32.const 2
i32.mul
!i32.const -2147483647!
!i32.mul!
            \end{lstlisting}
        \end{minipage}
    \end{minipage}
    \end{code}
}



\section{Answer to RQ1.}

We can provide diversification for 11.78\% of the programs in our corpora. We increase the initial count of programs by a factor of $4.15$. We identify the challenges attempting against the automated creation of programs variants, \emph{Constant computation} and \emph{Combination computation}. Nevertheless, the same constant computation, complemented with the high presence of arithmetic operations in the original program increased the number of program variants. 


\begin{comment}

While our work is very limited by the provided corpora, it can be easily extended to other\dots

An application that benefits from the ablity of CROW is the large amount of generated variants. 


- CHeckLong questions for 80%
- Stress how to do experiments in Software Engineering, the theory behind how to do this in CS.
- The objects of the experiments are programs that ... 
- Motivate the corpora selection, size, can be ported, security sensitive, etc,
- Do not mention CROW in the selection criteria.
- The motivation is not related to tools, only to concepts
- Move paragraph after listing of coprpora to before.
- 
%The proposed methodology can generate program variants that are syntactically different from their original versions. We have shown that CROW generates diversity among the binary code variants using semantically equivalent code transformations. We identified the properties that original programs should have to provide a handful number of variants. Besides, we enumerated the challenges faced to provide automatic diversification by retargeting a superoptimizer.

%In the next chapter, we evaluate the assessment of the generated variants answering to what extent the artificial programs are different from the original in terms of static difference, execution behavior, and preservation.

\end{comment}