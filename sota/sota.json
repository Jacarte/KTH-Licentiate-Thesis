[
    {
        "cite": "natural_diversity",
        "title": "The Multiple Facets of Software Diversity: Recent Developments in Year 2000 and Beyond",
        "authors": "Baudry and Monperrus",
        "seed": true,
        "year": 2015,
        "sum": "use of program evolution as a technique for defending against automated attacks on operating systems. The mentioned techniques can be applied in any sequence and recursively, providing a very rich environment for evolution. Increasing attack surface does not necesarilly has an impact on defence. For example, reordering instructions for code blocks that are never executed does not impact attacker.",
        "features": [
        
        {
            "level": 10,
            "category": "type",
            "description": "Dynamic",
            "id": "Dynamic",
            "slug": "dynamic"
        },
        {
            "level": 10,
            "category": "type",
            "description": "Dynamic",
            "id": "Static",
            "slug": "static"
        }
    ]
    },
    {
        "cite": "cohen1993operating",
        "title": "Operating system protection through program evolution",
        "authors": "Cohen etal",
        "seed": true,
        "year": 1993,
        "sum": "use of program evolution as a technique for defending against automated attacks on operating systems. The mentioned techniques can be applied in any sequence and recursively, providing a very rich environment for evolution. Increasing attack surface does not necesarilly has an impact on defence. For example, reordering instructions for code blocks that are never executed does not impact attacker.",
        "features": [
            {
                "level": 1,
                "id": "ND", 
                "category": "manual+prexisting",
                "description": "Use of prexisting programs or variants to build a resilient system. Meta compiler for example in the case of reliability. ",
                "slug": "natural_diversity"
            },
            {
                "level": 1,
                "id": "AD",
                "category": "automatic",
                "description": "Create diversification using a program seed.",
                "slug": "artificial_diversity"
            },
            {
                "level": 9,
                "category": "goal",
                "description": "",
                "id": "\\autoref{goal:reliability}",
                "slug": "fault_tolerance"
            },
            {
                "level": 9,
                "category": "goal",
                "description": "",
                "id": "\\autoref{goal:security}",
                "slug": "security"
            },
            {
                "level": 3,
                "id": "\\autoref{strategy:S1}",
                "type": "static",
                "category": "automatic",
                "slug": "equivalence_sequences",
                "description": "Complexity dramatically increases while the difficult of creating the evolution is minimal",
                "overhead": {
                    "time": 1,
                    "space": 1,
                    "reason": "If we use only space equivalent replacements, we may be severyly limited, while some evolutions may exchaange time with soace so as to maje the resulting programs either faster or slower."
                }
            },
            {
                "level": 3,
                "id": "\\autoref{strategy:S2}",
                "category": "automatic",
                "slug": "instruction_reordering",
                "description": "Requires no additional time or space while provides n! different variants, but this may not dive up the complexity attack in cases where specific instructions are being sought for bypass.",
                "type": "static",
                "overhead": {
                    "time": 0,
                    "space": 0
                }
            },
            {
                "level": 3,
                "id": "\\autoref{strategy:S3}",
                "category": "automatic",
                "slug": "adding_and_removing_jumps",
                "description": "",
                "type": "static",
                "overhead": {
                    "time": 1,
                    "space": 1,
                    "reason": "Programs are mainly lead by loops, adding arbitrary jumps might increase the execution time drastically."
                }
            },
            {
                "level": 3,
                "id": "\\autoref{strategy:S4}",
                "slug": "aslr",
                "category": "automatic",
                "description": "Memory layout randomization.",
                "type": "static",
                "overhead": {
                    "time": 1,
                    "space": 1,
                    "reason": ""
                }
            },
            {
                "level": 3,
                "id": "\\autoref{strategy:S5}",
                "slug": "isa_randomization",
                "category": "automatic",
                "description": "Encoding the original program for example by using a simple XOR. This technique is strong against attacks involving examination of code. It uses alone is not sufficient for defending againts serious attacks.",
                "type": "static+runtime",
                "overhead": {
                    "time": 0.5,
                    "space": 0,
                    "reason": "There is only one decoding operation at the begining or the receiving of the encoded program."
                }
            },
            {
                "level": 4,
                "id": "\\autoref{strategy:S10}",
                "category": "natural diversity",
                "slug": "intermixing",
                "description": "Complex to achieve because the integrity of the memory and stack needs to be ok. ",
                "type": "static+runtime",
                "overhead": {
                    "time": 0,
                    "space": 0,
                    "reason": "In theory, after detecting the simulator, its execution should be the same along all program versions."
                }
            },
            {
                "level": 7,
                "id": "\\autoref{usage:n-version}",
                "category": "usage",
                "slug": "nversion",
                "description": "Target architecture or context, e.g. x86",
                "type": "usage"
            },
            {
                "level": 7,
                "id": "\\autoref{usage:randomization}",
                "category": "usage",
                "slug": "srand",
                "description": "Target architecture or context, e.g. x86",
                "type": "usage"
            },
            {
                "level": 7,
                "id": "\\autoref{usage:mve}",
                "category": "usage",
                "slug": "mveu",
                "description": "Target architecture or context, e.g. x86",
                "type": "mve"
            },
            {
                "level": 6,
                "id": "Arch",
                "category": "means",
                "slug": "architecture",
                "description": "Target architecture or context, e.g. x86",
                "type": "static"
            },
            {
                "level": 6,
                "id": "Main technical contribution",
                "category": "means",
                "slug": "mean",
                "description": "Use of tools, e.g. compiler",
                "type": "static"
            }
        ]
    },
    {
        "cite": "MTDNationalCyberLaep",
        "title": "National Cyber Leap Year",
        "authors": "",
        "seed": true,
        "year": 2015,
        "sum": "",
        "features": [{
            "level": 5,
            "id": "Number of variants", 
            "category": "runtime",
            "description": "Interleave execution between variants",
            "slug": "number_of_variants"
        }
    ]
    },
    {
        "cite": "595185",
        "title": "Building diverse computer systems",
        "authors": "Forrest \\etal",
        "seed": true,
        "year": 1997,
        "sum": "Randomization of the amount of memory allocated on a stack frame is shown to disrupt a simple buffer overflow attack.",
        "features": [
        ]
    },
    {
        "cite": "homescu2013profile",
        "title": "Compiler-generated software diversity",
        "authors": "Homescu \\etal",
        "seed": false,
        "year": 2013,
        "sum": "Proposed inserting NOP instruction directly in LLVM IR to generate a variant with a different code layout at each compilation.",
        "features": [
            {
                "slug": "equivalence_sequences",
                "description": "Insert NOP operations"
            },
            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "static"
            },
            {
                "slug": "architecture",
                "description": "all LLVM supported, version 3.1"
            },
            {
                "slug": "mean",
                "special": "LLVM 3.1.0$^\\dagger$"
            },
            {
                "slug": "srand"
            },
            {
                "slug": "equivalence_checking",
                "description": ""
            },
            {
                "slug": "nvariant"
            }
        ]
    },
    {
        "cite": "jackson",
        "title": "On the Design, Implications, and Effects of Implementing Software Diversity for Security",
        "authors": "Jackson ",
        "seed": false,
        "year": 2012,
        "sum": "Have explored how to use NOP operations inserted during compiling time to statically diversify programs.",
        "features": [
            {
                "slug": "equivalence_sequences",
                "description": "Insert NOP operations"
            },
            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "static"
            },
            {
                "slug": "architecture",
                "description": "\\todo{}"
            },
            {
                "slug": "srand"
            },
            {
                "slug": "mveu"
            },
            {
                "slug": "mean",
                "special": "LLVM compiler, only backend for x86 architecture"
            },
            {
                "slug": "equivalence_checking"
            },
            {
                "slug": "nvariant"
            }
        ]
    },
    {
        "cite": "ElKhalil2004",
        "title": "Hydan: Hiding Information in Program Binaries",
        "authors": "El-Khalil and Keromytis ",
        "seed": false,
        "year": 2004,
        "sum": "modified a version of GCC 4.1 to separate a conventional stack into several component parts, called multistacks.",
        "features": [
            
            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "static"
            },
            {
                "slug": "srand"
            },
            {
                "slug": "architecture",
                "description": "\\todo{}"
            },
            {
                "slug": "mean",
                "special": "custom GCC compiler for x86 architecture"
            },
            {
                "slug": "equivalence_checking"
            },
            {
                "slug": "nvariant"
            }
        ]
    },
    {
        "cite": "ElKhalil2004",
        "title": "Compiler mitigations for time attacks on modern x86 processors",
        "authors": "Cleemput \\etal ",
        "seed": false,
        "year": 2012,
        "sum": "Cleemput et al. [30] suggest inserting NOP instructions be tween dependent store and load instructions to prevent pipeline stalls. Their analysis shows that in order to prevent leakage of any information about the encryption key, at least six NOP instructions need to be inserted. This work can be adapted to a diversifying compiler, but at significant performance overhead. Cleemput et al. suggested a minimum of six NOP instructions for an overhead of 1.85x. A diversifying compiler would have to randomly add more NOPs",
        "features": [
            
            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "equivalence_sequences"
            },
            {
                "slug": "static"
            },
            {
                "slug": "srand"
            },
            {
                "slug": "architecture",
                "description": "\\todo{}"
            },
            {
                "slug": "mean",
                "special": "x86 to x86 transformations"
            },
            {
                "slug": "equivalence_checking"
            },
            {
                "slug": "nvariant"
            }
        ]
    },{
        "cite": "Younan2006",
        "title": "Extended Protection against Stack Smashing Attacks without Performance Loss",
        "authors": "Younan \\etal ",
        "seed": false,
        "year": 2006,
        "sum": "Younan et al. [120] modified a version of GCC 4.1 to separate a conventional stack into several component parts, called multistacks. Each part contains a particular class of stack data. Their implementation is incompatible with many ASLR implementations, but can be modified. Multistacks were later ported to ARM [109]",
        "features": [
            
            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "static"
            },
            {
                "slug": "aslr"
            },
            {
                "slug": "architecture",
                "description": "\\todo{}"
            },
            {
                "slug": "mean",
                "special": "custom GCC compiler"
            },
            {
                "slug": "equivalence_checking"
            },
            {
                "slug": "nvariant"
            }
        ]
    },
    {
        "cite": "pettisochhansen",
        "title": "Profile guided code positioning",
        "authors": "Pettis and Hansen",
        "seed": false,
        "year": 1990,
        "sum": "investigated rearranging both functions and basic blocks as well as splitting functions for performance purposes on the PA-RISC architecture",
        "features": [
            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "instruction_reordering"
            },
            {
                "slug": "srand"
            },
            {
                "slug": "aslr"
            },
            {
                "slug": "static"
            },
            {
                "slug": "architecture",
                "description": "Custom Pascal compiler for PA-RISC architecture"
            },
            {
                "slug": "mean",
                "special": "Custom Pascal compiler for PA-RISC architecture"
            }
        ]
    },
    {
        "cite": "amarilli2011can",
        "title": "Can code polymorphism limit information leakage?",
        "authors": "Amarilli \\etal ",
        "seed": false,
        "year": 2011,
        "sum": "is the first to propose the generation of code variants against side-channel attacks..",
        "features": [
            {
                "slug": "dynamic"
            },
            {
                "slug": "security"
            },
            {
                "slug": "equivalence_sequences"
            },
            {
                "slug": "mean",
                "special": "Polymorphic code generator for ARM architecture"
            },
            {
                "slug": "isa_randomization"
            },
            {
                "slug": "srand"
            }
        ]
    },
    
    {
        "cite": "crane2015thwarting",
        "title": "Thwarting Cache Side-Channel Attacks Through Dynamic Software Diversity.",
        "authors": "Crane \\etal ",
        "seed": false,
        "year": 2015,
        "sum": "modify the LLVM toolchain to compile multiple functionally equivalent variants to randomize the control flow of software",
        "features": [
            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "static"
            },
            {
                "slug": "dynamic"
            },
            {
                "slug": "intermixing"
            },
            {
                "slug": "number_of_variants",
                "description": "N"
            },
            {
                "slug": "security",
                "description": "mitigation"
            },
            {
                "slug": "architecture",
                "description": "all LLVM supported"
            },
            {
                "slug": "mean",
                "special": "LLVM, only backend for x86 architecture"
            },
            {
                "slug": "adding_and_removing_jumps"
            },
            {
                "slug": "instruction_reordering"
            },
            {
                "slug": "equivalence_sequences"
            },
            {
                "slug": "nvariant"
            },
            {
                "slug": "mveu"
            }
        ]
    },
    {
        "cite": "courousse2016runtime",
        "title": "Runtime code polymorphism as a protection against side channel attacks \\todo{recheck}",
        "authors": "Courouss{\\'e} \\etal ",
        "seed": false,
        "year": 2016,
        "sum": "implement an assembly-like DSL to generate equivalent code at runtime in order to increase protection against side-channel attacks.",
        "features": [
            {
                "slug": "security",
                "description": "power side-channel mitigation"
            },
            {
                "slug": "static"
            },
            {
                "slug": "dynamic"
            },
            {
                "slug": "instruction_reordering"
            },
            {
                "slug": "equivalence_sequences"
            },
            {
                "slug": "intermixing"
            },
            {
                "slug": "number_of_variants",
                "description": "N"
            },
            {
                "slug": "architecture",
                "description": "microcontrollers"
            },
            {
                "slug": "mean",
                "special": "Custom GCC compiler targeting microcontrollers"
            },
            {
                "slug": "isa_randomization"
            },
            {
                "slug": "srand"
            }
        ]
    },
    {
        "cite": "Kc03",
        "title": "Countering code-injection attacks with instruction-set randomization",
        "authors": "Kc \\etal ",
        "seed": false,
        "year": 2003,
        "sum": "to create a unique mapping between artificial CPU instructions and real ones. This makes it very hard for an attacker to ignore the key to inject executable code. This breaks the predictability of program execution and mitigates certain exploits.",
        "features": [
            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "isa_randomization"
            },
            {
                "slug": "isa_randomization"
            },
            {
                "slug": "isa_randomization"
            },
            {
                "slug": "static"
            },
            {
                "slug": "dynamic"
            },
            {
                "slug": "architecture",
                "description": "x86"
            },
            {
                "slug": "mean",
                "special": "Linux Kernel recompilation."
            },
            {
                "slug": "security"
            },
            {
                "slug": "nvariant"
            }
        ]
    },
    {
        "cite": "barrantes2003randomized",
        "title": "Randomized instruction set emulation to disrupt binary code injection attacks",
        "authors": "Barrantes \\etal ",
        "seed": false,
        "year": 2003,
        "sum": "to create a unique mapping between artificial CPU instructions and real ones. This makes it very hard for an attacker to ignore the key to inject executable code. This breaks the predictability of program execution and mitigates certain exploits.",
        "features": [
            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "isa_randomization"
            },
            {
                "slug": "static"
            },
            {
                "slug": "dynamic"
            },
            {
                "slug": "architecture",
                "description": "x86 to x86 transformations"
            },
            {
                "slug": "mean",
                "special": "x86 to x86 transformations using Valgrind"
            },
            {
                "slug": "security"
            },
            {
                "slug": "srand"
            }
        ]
    },
    {
        "cite": "Chew02mitigatingbuffer",
        "title": "Mitigating buffer overflows by operating system randomization",
        "authors": "Chew and Song",
        "seed": false,
        "year": 2002,
        "sum": "They randomize the interface between the operating system and the user applications: the system call numbers, the library entry points (memory addresses), and the stack placement. All those techniques are dynamic, done at runtime using load-time preprocessing and rewriting.",
        "features": [
            {
                "slug": "adding_and_removing_jumps",
                "description": "change the table of system calls and recompile the kernel. Besides, randomization of the program stack placement."
            },
            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "architecture",
                "description": "Linux Kernel"
            },
            {
                "slug": "mean",
                "special": "Linux Kernel recompilation."
            },
            {
                "slug": "dynamic"
            },
            {
                "slug": "srand"
            }
        ]
    },
    {
        "cite": "bhatkar03",
        "title": "Address obfuscation: an efficient approach to combat a board range of memory error exploits",
        "authors": "Bhatkar \\etal",
        "seed": false,
        "year": 2003,
        "sum": "proposed three kinds of randomization transformations: randomizing the base addresses of applications and libraries  memory regions, random permutation of the order of variables and routines, and the random introduction of random gaps between objects. Dynamic randomization can address different kinds of problems. ",
        "features": [
            
            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "dynamic"
            },
            {
                "slug": "equivalence_sequences"
            },
            {
                "slug": "security"
            },
            {
                "slug": "aslr"
            },
            {
                "slug": "instruction_reordering"
            },
            {
                "slug": "instruction_reordering"
            },
            {
                "slug": "gap_insertion"
            },
            {
                "slug": "mean",
                "special": "ELF binary transformations"
            },
            {
                "slug": "security"
            },
            {
                "slug": "srand"
            }
        ]
    },
    {
        "cite": "bhatkar2005efficient",
        "title": "Efficient techniques for comprehensive protection from memory error exploits",
        "authors": "Bhatkar \\etal",
        "seed": false,
        "year": 2005,
        "sum": "proposed three kinds of randomization transformations: randomizing the base addresses of applications and libraries  memory regions, random permutation of the order of variables and routines, and the random introduction of random gaps between objects. Dynamic randomization can address different kinds of problems. ",
        "features": [

            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "dynamic"
            },
            {
                "slug": "equivalence_sequences"
            },
            {
                "slug": "security"
            },
            {
                "slug": "aslr"
            },
            {
                "slug": "instruction_reordering"
            },
            {
                "slug": "instruction_reordering"
            },
            {
                "slug": "gap_insertion"
            },
            {
                "slug": "mean",
                "special": "C/C++ source to source transformations and ELF binary transformations"
            },
            {
                "slug": "security"
            },
            {
                "slug": "srand"
            }
        ]
    },
    {
        "cite": "aga2019smokestack",
        "title": "Smokestack: thwarting DOP attacks with runtime stack layout randomization",
        "authors": "Aga \\etal",
        "seed": false,
        "year": 2019,
        "sum": "data-oriented programming \\cite{aga2019smokestack}, and memory safety violations \\cite{lee2021savior}, as well as a technique to reduce the exposure time of persistent memory objects to increase the frequency of address randomization ",
        "features": [
            {
                "slug": "aslr"
            },
            {
                "slug": "security",
                "description": "DOP gadget mitigation"
            },
            {
                "slug": "architecture",
                "description": "all supported by LLVM version 3.9"
            },
            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "mean",
                "special": "Data layout randomization, LLVM 3.9$^\\dagger$"
            },
            {
                "slug": "static"
            },
            {
                "slug": "srand"
            }
        ]
    },
    {
        "cite": "lee2021savior",
        "title": "SaVioR: Thwarting Stack-Based Memory Safety Violations by Randomizing Stack Layout",
        "authors": "Lee \\etal",
        "seed": false,
        "year": 2021,
        "sum": "data-oriented programming \\cite{aga2019smokestack}, and memory safety violations \\cite{lee2021savior}, as well as a technique to reduce the exposure time of persistent memory objects to increase the frequency of address randomization ",
        "features": [
            {
                "slug": "aslr"
            },
            {
                "slug": "secuaga2019smokestackrity",
                "description": "stack protection mechanism"
            },
            {
                "slug": "architecture",
                "description": "all supported by LLVM version \\todo{XXX}"
            },
            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "mean",
                "special": "LLVM 12.0.0 backend for x86"
            },
            {
                "slug": "static"
            },
            {
                "slug": "srand"
            }
        ]
    },
    {
        "cite": "xu2020merr",
        "title": "Merr: Improving security of persistent memory objects via efficient memory exposure reduction and randomization",
        "authors": "Xu \\etal",
        "seed": false,
        "year": 2020,
        "sum": "as well as a technique to reduce the exposure time of persistent memory objects to increase the frequency of address randomization",
        "features": [
            {
                "slug": "aslr"
            },
            {
                "slug": "security",
                "description": "stack protection mechanism"
            },
            {
                "slug": "architecture"
            },
            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "mean",
                "special": "Custom kernel module in Linux OS"
            },
            {
                "slug": "dynamic",
                "description": "attaching and detaching memory between memory accesses"
            },
            {
                "slug": "srand"
            }
        ]
    }
    ,
    {
        "cite": "bruschi2007diversified",
        "title": "Diversified process replic{\\ae} for defeating memory error exploits",
        "authors": "Bruschi \\etal",
        "seed": false,
        "year": 2007,
        "sum": "pioneered the idea of executing the variants in parallel.",
        "features": [

            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "security",
                "description": ""
            },
            {
                "slug": "aslr"
            },
            {
                "slug": "intermixing"
            },
            {
                "slug": "mean",
                "special": "ELF binary transformations."
            },
            {
                "slug": "dynamic"
            },
            {
                "slug": "srand"
            }
        ]
    },
    {
        "cite": "salamat2007stopping",
        "title": "Stopping Buffer Overflow Attacks at Run-Time: Simultaneous Multi-Variant Program Execution on a Multicore Processor",
        "authors": "Salamat \\etal",
        "seed": false,
        "year": 2007,
        "sum": "pioneered the idea of executing the variants in parallel.",
        "features": [

            {
                "slug": "artificial_diversity"
            },

            {
                "slug": "security",
                "description": "mitigate known vulnerabilities through moving target defence."
            },
            {
                "slug": "intermixing"
            },
            {
                "slug": "number_of_variants",
                "description": "N"
            },
            {
                "slug": "mean",
                "special": "Custom GNU compiler"
            },
            {
                "slug": "dynamic"
            },
            {
                "slug": "architecture"
            },
            {
                "slug": "adding_and_removing_jumps"
            },
            {
                "slug": "mean",
                "special": "Custom  GNU compiler"
            },
            {
                "slug": "mveu"
            }
        ]
    },
    {
        "cite": "lu2018stopping",
        "title": "Stopping memory disclosures via diversification and replicated execution",
        "authors": "Lu \\etal",
        "seed": false,
        "year": 2018,
        "sum": "Subsequent techniques focus on Multivariant Execution (MVE) for mitigating memory vulnerabilities. We transform the detection problem into an equivalence-check problem by seamlessly maintaining two identical instances of a target process and diversifying only the target data. ",
        "features": [

            {
                "slug": "artificial_diversity"
            },

            {
                "slug": "security",
                "description": "mitigate memory vulnerabilities"
            },
            {
                "slug": "intermixing"
            },
            {
                "slug": "number_of_variants",
                "description": "N"
            },
            {
                "slug": "aslr"
            },
            {
                "slug": "mean",
                "special": "GNU assembler for Linux kernel"
            },
            {
                "slug": "dynamic"
            },
            {
                "slug": "mveu"
            },
            {
                "slug": "mveu"
            }
        ]
    },
    {
        "cite": "osterlund2019kmvx",
        "title": "kMVX: Detecting kernel information leaks with multi-variant execution",
        "authors": "{\\\"O}sterlund \\etal",
        "seed": false,
        "year": 2019,
        "sum": "For our variant generation, we modify existing kernel allocators to yield different usage patterns between variants. In particular, we apply variant generation by partitioning the address space, modifying dynamic allocators such as the SLAB allocator, and changing the format of the stack with a compiler pass. ",
        "features": [
            {
                "slug": "mveu"
            },
            {
                "slug": "aslr"
            },
            {
                "slug": "mean",
                "special": "Linux Kernel recompilation."
            },
            {
                "slug": "artificial_diversity"
            }
        ]
    },
    {
        "cite": "salamat2009orchestra",
        "title": "Orchestra: intrusion detection using parallel execution and monitoring of program variants in user-space",
        "authors": "Salamat \\etal",
        "seed": false,
        "year": 2009,
        "sum": " in user-space. A new technique for variant generation based on reversing the direction of stack growt ",
        "features": [
            {
                "slug": "mveu"
            },
            {
                "slug": "mean",
                "special": "x86 to x86 transformations"
            },
            {
                "slug": "aslr"
            },
            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "number_of_variants",
                "description": "2"
            }
        ]
    },
    {
        "cite": "10.1145/3281662",
        "title": "Automated Software Protection for the Masses Against Side-Channel Attacks",
        "authors": "Belleville \\etal",
        "seed": false,
        "year": 2018,
        "sum": " or even through code polymorphism  ",
        "features": [
            {
                "slug": "srand"
            },
            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "mean",
                "special": "Only C language frontend, LLVM 3.8.0$^\\dagger$"
            },
            {
                "slug": "equivalence_sequences"
            },
            {
                "slug": "aslr"
            },
            {
                "slug": "equivalence_sequences"
            },
            {
                "slug": "security"
            }
        ]
    },
    {
        "cite": "maurer2012tachyon",
        "title": "TACHYON: Tandem execution for efficient live patch testing",
        "authors": "Maurer \\etal",
        "seed": true,
        "year": 2012,
        "sum": " Finally, one can neatly exploit the limit case of executing only two variant",
        "features": [
            
        ]
    },
    {
        "cite": "davi2015isomeron",
        "title": "Isomeron: Code Randomization Resilient to (Just-In-Time) Return-Oriented Programming",
        "authors": "Davi \\etal",
        "seed": false,
        "year": 2015,
        "sum": " an approach  for execution-path randomization. Isomeron simultaneously loads the original program and a variant. While the program is running, Isomeron continuously flips a coin to decide which copy of the program should be executed next at the level of function calls. With this strategy a potential attacker cannot predict whether the original or the variant of a program will execute.",
        "features": [
            {
                "slug": "number_of_variants",
                "description": "2"
            },
            {
                "slug": "intermixing"
            },
            {
                "slug": "security",
                "description" : "to mitigate JIT-ROP attacks"
            },
            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "dynamic",
                "description": "Execution path randomization"
            },
            {
                "slug": "mean",
                "special": "Windows DLL instrumentation"
            },
            {
                "slug": "srand"
            }
        ]
    },
    {
        "cite": "jacob2008superdiversifier",
        "title": "The superdiversifier: Peephole individualization for software protection",
        "authors": "Jacob \\etal",
        "seed": false,
        "year": 2008,
        "sum": "proposed a multivariant execution system by parallelizing the execution of the variants in different machines ",
        "features": [
            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "equivalence_sequences"
            },
            {
                "slug": "equivalence_sequences"
            },
            {
                "slug": "instruction_reordering"
            },
            {
                "slug": "static"
            },
            {
                "slug": "mean",
                "special": "x86 to x86 transformations"
            },
            {
                "slug": "nversion"
            }
        ]
    },
    {
        "cite": "CROW",
        "title": "",
        "authors": "Cabrera Arteaga \\etal",
        "seed": false,
        "year": 12021,
        "sum": " ",
        "features": [
            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "equivalence_sequences"
            },
            {
                "slug": "equivalence_sequences"
            },
            {
                "slug": "instruction_reordering"
            },
            {
                "slug": "instruction_reordering"
            },
            {
                "slug": "adding_and_removing_jumps"
            },
            {
                "slug": "security"
            },
            {
                "slug": "reliability"
            },
            {
                "slug": "aslr"
            },
            {
                "slug": "nversion"
            },
            {
                "slug": "mean",
                "special": "Any frontend language for LLVM version 12.0.0 targeting Wasm backend"
            },
            {
                "slug": "srand"
            }
        ]
    },
    {
        "cite": "MEWE",
        "title": "",
        "authors": "Cabrera Arteaga \\etal",
        "seed": false,
        "year": 12022,
        "sum": "",
        "features": [
            {
                "slug": "artificial_diversity"
            },
            {
                "slug": "mean",
                "special": "Any frontend and backend language for LLVM version 12.0.0"
            },
            {
                "slug": "equivalence_sequences"
            },
            {
                "slug": "equivalence_sequences"
            },
            {
                "slug": "instruction_reordering"
            },
            {
                "slug": "instruction_reordering"
            },
            {
                "slug": "adding_and_removing_jumps"
            },
            {
                "slug": "adding_and_removing_jumps"
            },
            {
                "slug": "aslr"
            },
            {
                "slug": "intermixing"
            },
            {
                "slug": "security"
            },
            {
                "slug": "reliability"
            },
            {
                "slug": "mveu"
            }
        ]
    }
]