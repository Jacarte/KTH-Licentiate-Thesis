\chapter{Methodology} 
\label{chapter:method}

\pagestyle{plain}
% Define some numbers here for the autmation of the tables
\newcommand{\libsodiumfunctions}{869}
\newcommand{\qrcodefunctions}{1849}
\newcommand{\allmewefunctions}{\libsodiumfunctions + \qrcodefunctions}

% Execute a python script for small calculations
\newcommand{\py}[1]{\input{|python3 interpreter.py #1}}
\newcommand{\fromjson}[2]{\input{| jq -r '#2' #1}}

\newcommand{\corpusrosetta}{\fromjson{data/crow_corpus.json}{.[0].name}}
\newcommand{\corpussodium}{Libsodium\xspace}
\newcommand{\corpusqrcode}{QrCode\xspace}


\newcommand{\DTWStatic}{dt\_static\xspace}
\newcommand{\DTW}{dt\_dyn\xspace}
\newcommand{\tool}{CROW\xspace}


%This chapter investigates whether we can artificially create program variants through semantically equivalent code transformations. We propose a framework to generate program variants functionally equivalent to their original.
%We introduce the retargeting of a superoptimizer, using its exhaustive search strategy to provide semantically equivalent code transformations. 
%The presented methodology and transformation tool, CROW, are contributions to this thesis.
%We evaluate the usage of CROW on two corpora of open-source and nature diverse programs. 
In this chapter, we present our methodology to answer the research questions enunciated in \autoref{intro:definition:rq}.
We investigate three research questions. In the first question, we artificially generate \wasm program variants, and we qualitatively compare the static differences between variants. 
Our second research question focuses on comparing their behavior during their execution.
The final research question evaluates the feasibility of using the program variants in security-sensitive environments such as Edge-Cloud computing proposing a multivariant execution approach.

The main objective of this thesis is to study the feasibility of automatically creating programs variant out of preexisting program sources or case studies. To achieve this objective,
we use an empirical method \cite{Runeson2020}, proposing a solution and evaluating it through quantitative analyzes in case studies. We follow an iterative and incremental approach that start with the selection of the program corpora to be amplified through automated diversification. To build our corpora we find a representative and diverse set of programs in order to generalize, even when it is unrealistic following an empirical approach, as much as possible our results.
We first enunciate the corpora we share along all this work to answer our research questions. Then, for each research question, we establish the metrics, set the configuration for the experiments, and describe the protocol.


% Our approach lies under \textit{Design Science} \cite{Runeson2020}, in terms of empirical validation, the scope of the design knowledge gained in a study can be extended by systematically extending the scope of the valudation in subsequent studies. Thus, the size of our corpora can be extended to increase the knowledge of the research area.


\section{Corpora}
\label{section:crow:corpora}

Our experiments assess the impact of artificially created diversity in terms of program variants size, static and dynamic differences. The first step is to build a suitable corpus of programs' seeds to generate the variants. We answer all our research questions with three corpora of diverse and representative programs for our experiments. 
We build our three corpora in an escalating strategy. The first corpus is diverse and contains simple programs in terms of code size, making them easy to manually analyze. The latter two corpora contain more extensive real-world programs, including one project meant for security-sensitive applications. Finally, all corpora are considered to come along the LLVM pipeline. We base this decision on the previous experimental work of Hilbig \etal \cite{Hilbig2021AnES}. This work shows that approximately 65\% of all \wasm programs come out of C/C++ source code, and more than 75\% if Rust is included. In the following, we describe the filtering and description of each corpus.

\begin{enumerate}
    \item \textbf{\corpusrosetta}: We take programs from the  Rosetta Code project\footnote{\url{http://www.rosettacode.org/wiki/Rosetta_Code}}. This website hosts a curated set of solutions for specific programming tasks in various  programming languages. It contains a wide range of tasks, from simple ones, such as adding two numbers, to complex algorithms like a compiler lexer.  We first collect all C programs from Rosetta Code, which represents $989$ programs as of 01/26/2020.  We then apply a number of filters: the programs should successfully compile and, they should not require user inputs in order to automatically execute them, the programs should terminate and should not result in non-deterministic results. 
    
    The result of the filtering is a corpus of 303 C programs. All programs include a single function in terms of source code. These programs range from $7$ to $150$ lines of code and solve a variety of problems, from the \textit{Babbage} problem to  \textit{Convex Hull} calculation.

    \item \textbf{\corpussodium}: This project is an encryption, decryption, signature and password hashing library which have been ported to WebAssembly in 102 separated modules. The modules have between $8$ and $2703$ lines of code per function. This project is selected based on two main criteria: first, its importance for security related applications and second, its suitability to collect the modules in LLVM intermediate representation. Besides, this project contains a mature testing implementation, which gives us the possibility of executing the majority of the modules with a Wasm/WASI engine. This late reason allows us to dynamically compare the generated program variants.

    \item \textbf{\corpusqrcode}: This project is a QrCode and MicroQrCode generator written in Rust. This project contains \todo{XXX} modules having between $4$ and $725$ lines of code per function. As \corpussodium, we select this project due to its suitability for collecting the modules in their LLVM representation.
    \todo{Expand, motivate}
\end{enumerate}

In \autoref{table:corpora} we listed the corpus name, the number of programs inside the corpus, the total number of functions, the range of lines of code, and the original location of the corpus. 


%The first corpus, \textbf{CROW prime}, . The second corpus, \textbf{MEWE prime}, is part of the MEWE contribution \cite{}. In \autoref{table:corpora} we summarize the selection criteria, and we mention each corpus properties. With both corpora we evaluate CROW with a total of $303 + \py{\allmewefunctions}$ functions. 

\begin{table}[h]
    \renewcommand{\arraystretch}{1.0}
    \small
    \centering
    \begin{tabular}{l  | l | l | l | p{2.8cm}}
        Corpus name & No. programs & No. functions & LOC range & Location \\
        \midrule
            % CROW
            \corpusrosetta &
            \fromjson{data/crow_corpus.json}{.[0].programs} &
            \fromjson{data/crow_corpus.json}{.[0].functions}  & 
            \fromjson{data/crow_corpus.json}{.[0].min_lines} - 
            \fromjson{data/crow_corpus.json}{.[0].max_lines} & 
            \fromjson{data/crow_corpus.json}{.[0].url} \\
        \hline
        \corpussodium & 
        5 & 
        \fromjson{data/allinone.multivariant.bc.massive.sodium.json}{.total_functions}  &
        \fromjson{data/allinone.multivariant.bc.massive.sodium.json}{.min_llvm_loc} - \fromjson{data/allinone.multivariant.bc.massive.sodium.json}{.max_llvm_loc}  &   
        \url{https://github.com/jedisct1/libsodium }\\
        \hline
        \corpusqrcode & 
        2 & 
        \fromjson{data/allinone.multivariant.bc.massive.qr.json}{.total_functions}  & 
        \fromjson{data/allinone.multivariant.bc.massive.qr.json}{.min_llvm_loc} - \fromjson{data/allinone.multivariant.bc.massive.qr.json}{.max_llvm_loc}   & 
        \url{https://github.com/kennytm/qrcode-rust} \\
        % Total stats
        \hline
        \hline
        \textbf{Total} & 
        \py{
        5 + 2 + 303} &   
        \py{ 303 + \qrcodefunctions + \libsodiumfunctions} &  
        &     \\

    \end{tabular}
    \caption{Corpora description. The table is composed by the name of the corpus, the number of programs, the number of functions, the lines of code range and the location of the corpus.}
    \label{table:corpora}
\end{table}

\input{method/RQ1.tex}

\input{method/RQ2.tex}

\input{method/RQ3.tex}



\section{Conclusions}

This chapter presents the methodology we follow to answer our three research questions. We first describe and propose the corpora of programs used in this work. We propose to measure the ability of our approach to generate variants out of \py{303  + \libsodiumfunctions + \qrcodefunctions} functions of our corpora. Then, we suggest using the generated variants to study to what extent they offer different observable behavior through  dynamic analysis. Finally, we propose a protocol to study the impact of the composition variants in a multivariant binary deployed at the Edge. Nevertheless, we enumerate and enunciate the properties and metrics that might lead us to answer the impact of automatic diversification for \wasm programs. In the next chapter, we present and discuss the results obtained with this methodology.