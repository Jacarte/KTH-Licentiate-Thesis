
\chapter{Methodology} 
\label{chapter:method}

\pagestyle{plain}
% Define some numbers here for the autmation of the tables
\newcommand{\libsodiumfunctions}{869}
\newcommand{\qrcodefunctions}{1849}
\newcommand{\allmewefunctions}{\libsodiumfunctions + \qrcodefunctions}

% Execute a python script for small calculations
\newcommand{\py}[1]{\input{|python3 interpreter.py #1}}
\newcommand{\fromjson}[2]{\input{| jq -r '#2' #1}}

\newcommand{\corpusrosetta}{\fromjson{data/crow_corpus.json}{.[0].name}}
\newcommand{\corpussodium}{Libsodium\xspace}
\newcommand{\corpusqrcode}{QrCode\xspace}


\newcommand{\DTWStatic}{dt\_static\xspace}
\newcommand{\DTW}{dt\_dyn\xspace}
\newcommand{\tool}{CROW\xspace}


%This chapter investigates whether we can artificially create program variants through semantically equivalent code transformations. We propose a framework to generate program variants functionally equivalent to their original.
%We introduce the retargeting of a superoptimizer, using its exhaustive search strategy to provide semantically equivalent code transformations. 
%The presented methodology and transformation tool, CROW, are contributions to this thesis.
%We evaluate the usage of CROW on two corpora of open-source and nature diverse programs. 
In this chapter, we present our methodology to answer the research questions enunciated in \autoref{chapter:introduction}.
We investigate three research questions. 
In the first question, we artificially generate \wasm program variant, and we qualitatively compare the ability of CROW, one of the contributions of this thesis, to generate statically different yet functionally equivalent variants. 
Our second research question statically compares the generated variants and compares their behavior through traces, execution time, and preservation through the machine code compiling process.
The final research question evaluates the feasibility of using the program variants in security-sensitive environments such as Edge-Cloud computing proposing a multivariant execution approach.


We share the same corpora of programs to answer all our research questions. We first enunciate the corpora of programs. Then, for each research question, we establish the metrics, set the configuration for the experiments, and describe the protocol for them.

\section{Corpora}
\label{section:crow:corpora}

Our experiments assess the impact of artificially created diversity. For such reason, the first step is to build a suitable corpus of programs to generate program variants. We then use the generated variants to study their static, dynamic, and security properties.  We answer all our research questions with three corpora of programs appropriate for our experiments. In \autoref{table:corpora} we listed the corpus name, the number of programs inside the corpus, the total number of functions, the range of lines of code, and the original location of the corpus. In the following, we describe the filtering and description of each corpus.

\begin{enumerate}
    \item \textbf{\corpusrosetta} corpus is part of the CROW contribution \cite{}. We take programs from the  Rosetta Code project\footnote{\url{http://www.rosettacode.org/wiki/Rosetta_Code}}. This website hosts a curated set of solutions for specific programming tasks in various  programming languages. It contains a wide range of tasks, from simple ones, such as adding two numbers, to complex algorithms like a compiler lexer.  We first collect all C programs from Rosetta Code, which represents $989$ programs as of 01/26/2020.  We then apply a number of filters: the programs should successfully compile, they should not require user inputs, the programs should terminate and should not provide in non-deterministic results. The result of the filtering is a corpus of 303 C programs. All programs have a single function in terms of source code. These programs range from $7$ to $150$ lines of code and solve a variety of problems, from the \textit{Babbage} problem to  \textit{Convex Hull} calculation.
    \item \textbf{\corpussodium} is part of both CROW and MEWE contributions \cite{} \cite{}. This project is an encryption, decryption, signature and password hashing library which can be ported to WebAssembly.
    We selected 5 programs or endpoints to answer our research questions. These endpoints have between $8$ and $2703$ lines of code per function.  The project is selected based on their suitability for  diversity synthesis with CROW, \ie the project should have the ability to collect its modules in LLVM intermediate representation and the project should be easily portable Wasm/WASI.

    \item \textbf{\corpusqrcode} is part of the MEWE contribution. This project is a QrCode and MicroQrCode generator written in Rust. We selected 2 programs or endpoints to answer our research questions. These endpoints have between $4$ and $725$ lines of code per function. As \corpussodium, we select this project due to its suitability for diversity synthesis with CROW.
\end{enumerate}

We build our corpora in an escalating strategy. The first corpus should illustrate the feasibility of CROW to generate program variants out of simple programs in terms of code size. The latter two corpora study the impact of CROW on more extensive real-world programs, including one project meant for security-sensitive applications. Overall, all corpora are considered to come along the LLVM pipeline, having the input for CROW from C/C++ source code or LLVM bitcodes. We base this decision on the previous experimental work of Lehman \etal \citationneeded. This work shows that more than 70\% of all \wasm programs come out of LLVM based tooling.

%The first corpus, \textbf{CROW prime}, . The second corpus, \textbf{MEWE prime}, is part of the MEWE contribution \cite{}. In \autoref{table:corpora} we summarize the selection criteria, and we mention each corpus properties. With both corpora we evaluate CROW with a total of $303 + \py{\allmewefunctions}$ functions. 

\begin{table}[h]
    \renewcommand{\arraystretch}{1.0}
    \small
    \centering
    \begin{tabular}{l  | l | l | l | p{2.8cm}}
        Corpus name & No. programs & No. functions & LOC range & Location \\
        \midrule
            % CROW
            \corpusrosetta &
            \fromjson{data/crow_corpus.json}{.[0].programs} &
            \fromjson{data/crow_corpus.json}{.[0].functions}  & 
            \fromjson{data/crow_corpus.json}{.[0].min_lines} - 
            \fromjson{data/crow_corpus.json}{.[0].max_lines} & 
            \fromjson{data/crow_corpus.json}{.[0].url} \\
        \hline
        \corpussodium & 
        5 & 
        \fromjson{data/allinone.multivariant.bc.massive.sodium.json}{.total_functions}  &
        \fromjson{data/allinone.multivariant.bc.massive.sodium.json}{.min_llvm_loc} - \fromjson{data/allinone.multivariant.bc.massive.sodium.json}{.max_llvm_loc}  &   
        \url{https://github.com/jedisct1/libsodium }\\
        \hline
        \corpusqrcode & 
        2 & 
        \fromjson{data/allinone.multivariant.bc.massive.qr.json}{.total_functions}  & 
        \fromjson{data/allinone.multivariant.bc.massive.qr.json}{.min_llvm_loc} - \fromjson{data/allinone.multivariant.bc.massive.qr.json}{.max_llvm_loc}   & 
        \url{https://github.com/kennytm/qrcode-rust} \\
        % Total stats
        \hline
        \hline
        \textbf{Total} & 
        \py{
        5 + 2 + 303} &   
        \py{ 303 + \qrcodefunctions + \libsodiumfunctions} &  
        &     \\

    \end{tabular}
    \caption{Corpora description. The table is composed by the name of the corpus, the number of programs, the number of functions, the lines of code range and the location of the corpus.}
    \label{table:corpora}
\end{table}

\input{method/RQ1.tex}

\input{method/RQ2.tex}

\input{method/RQ3.tex}