@inbook{Runeson2020,
  author    = {Runeson, Per
               and Engstr{\"o}m, Emelie
               and Storey, Margaret-Anne},
  editor    = {Felderer, Michael
               and Travassos, Guilherme Horta},
  title     = {The Design Science Paradigm as a Frame for Empirical Software Engineering},
  booktitle = {Contemporary Empirical Methods in Software Engineering},
  year      = {2020},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {127--147},
  abstract  = {Software engineering research aims to help improve real-world practice. With the adoption of empirical software engineering research methods, the understanding of real-world needs and validation of solution proposals have evolved. However, the philosophical perspective on what constitutes theoretical knowledge and research contributions in software engineering is less discussed in the community. In this chapter, we use the design science paradigm as a frame for articulating and communicating prescriptive software engineering research contributions. Design science embraces problem conceptualization, solution (or artifact) design, and validation of solution proposals, with recommendations for practice phrased as technological rules. Design science is used in related research areas, particularly information systems and management theory. We elaborate the constructs of design science for software engineering, relate them to different conceptualizations of design science, and provide examples of possible research methods. We outline how the assessment of research contributions, industry--academia communication, and theoretical knowledge building may be supported by the design science paradigm. Finally, we provide examples of software engineering research presented through a design science lens.},
  isbn      = {978-3-030-32489-6},
  doi       = {10.1007/978-3-030-32489-6_5},
  url       = {https://doi.org/10.1007/978-3-030-32489-6_5}
}

@article{Hilbig2021AnES,
  title   = {An Empirical Study of Real-World WebAssembly Binaries: Security, Languages, Use Cases},
  author  = {Aaron Hilbig and Daniel Lehmann and Michael Pradel},
  journal = {Proceedings of the Web Conference 2021},
  year    = {2021}
}


@inproceedings{moduloinputpaper,
  author    = {Le, Vu and Afshari, Mehrdad and Su, Zhendong},
  title     = {Compiler Validation via Equivalence modulo Inputs},
  year      = {2014},
  booktitle = {Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages     = {216–226},
  numpages  = {11},
  keywords  = {equivalent program variants, automated testing, miscompilation, compiler testing},
  location  = {Edinburgh, United Kingdom},
  series    = {PLDI ’14}
}
@article{Li2018,
  abstract  = {Security vulnerability is one of the root causes of cyber-security threats. To discover vulnerabilities and fix them in advance, researchers have proposed several techniques, among which fuzzing is the most widely used one. In recent years, fuzzing solutions, like AFL, have made great improvements in vulnerability discovery. This paper presents a summary of the recent advances, analyzes how they improve the fuzzing process, and sheds light on future work in fuzzing. Firstly, we discuss the reason why fuzzing is popular, by comparing different commonly used vulnerability discovery techniques. Then we present an overview of fuzzing solutions, and discuss in detail one of the most popular type of fuzzing, i.e., coverage-based fuzzing. Then we present other techniques that could make fuzzing process smarter and more efficient. Finally, we show some applications of fuzzing, and discuss new trends of fuzzing and potential future directions.},
  author    = {Li, Jun and Zhao, Bodong and Zhang, Chao},
  doi       = {10.1186/S42400-018-0002-Y/TABLES/5},
  file      = {:Users/javierca/Library/Application Support/Mendeley Desktop/Downloaded/Li, Zhao, Zhang - 2018 - Fuzzing a survey.pdf:pdf},
  issn      = {25233246},
  journal   = {Cybersecurity},
  keywords  = {Coverage-based fuzzing,Fuzzing,Software security,Vulnerability discovery},
  month     = {dec},
  number    = {1},
  pages     = {1--13},
  publisher = {Springer Science and Business Media B.V.},
  title     = {{Fuzzing: a survey}},
  url       = {https://cybersecurity.springeropen.com/articles/10.1186/s42400-018-0002-y},
  volume    = {1},
  year      = {2018}
}

@article{mann1947,
  author    = {Mann, H. B. and Whitney, D. R.},
  doi       = {10.1214/aoms/1177730491},
  fjournal  = {Annals of Mathematical Statistics},
  journal   = {Ann. Math. Statist.},
  month     = {03},
  number    = {1},
  pages     = {50--60},
  publisher = {The Institute of Mathematical Statistics},
  title     = {On a Test of Whether one of Two Random Variables is Stochastically Larger than the Other},
  volume    = {18},
  year      = {1947}
}


@inproceedings{Maia08usinga,
  author    = {Marcelo De A. Maia and Victor Sobreira and Klérisson R. Paixão and Ra A. De Amo and Ilmério R. Silva},
  title     = {Using a sequence alignment algorithm to identify specific and common code from execution traces},
  booktitle = {Proceedings of the 4th International Workshop on Program Comprehension through Dynamic Analysis (PCODA},
  year      = {2008},
  pages     = {6--10}
}


@inproceedings{davi2015isomeron,
  title     = {Isomeron: Code Randomization Resilient to (Just-In-Time) Return-Oriented Programming},
  author    = {Davi, Lucas and Liebchen, Christopher and Sadeghi, Ahmad-Reza and Snow, Kevin Z and Monrose, Fabian},
  booktitle = {NDSS},
  year      = {2015}
}

@article{gnanadesikan1968probability,
  title   = {Probability plotting methods for the analysis of data},
  author  = {Gnanadesikan, Ramanathan and Wilk, Martin B},
  journal = {Biometrika},
  volume  = {55},
  number  = {1},
  pages   = {1--17},
  year    = {1968}
}

@article{2021arXiv210808125C,
  author        = {{Cabrera Arteaga}, Javier and {Laperdrix}, Pierre and {Monperrus}, Martin and {Baudry}, Benoit},
  title         = {{Multi-Variant Execution at the Edge}},
  journal       = {arXiv e-prints},
  keywords      = {Computer Science - Software Engineering},
  year          = 2021,
  month         = aug,
  eid           = {arXiv:2108.08125},
  pages         = {arXiv:2108.08125},
  archiveprefix = {arXiv},
  eprint        = {2108.08125},
  primaryclass  = {cs.SE},
  adsurl        = {https://ui.adsabs.harvard.edu/abs/2021arXiv210808125C},
  adsnote       = {Provided by the SAO/NASA Astrophysics Data System}
}

@article{Haas_2017,
  title    = {Bringing the web up to speed with WebAssembly},
  year     = {2017},
  author   = {Andreas Haas and Andreas Rossberg and Derek L. Schuff and Derek L. Schuff and Ben L. Titzer and Michael Holman and Dan Gohman and Luke Wagner and Alon Zakai and J. F. Bastien},
  doi      = {10.1145/3062341.3062363},
  pmid     = {null},
  pmcid    = {null},
  mag_id   = {2625141509},
  journal  = {PLDI},
  abstract = {The maturation of the Web platform has given rise to sophisticated and demanding Web applications such as interactive 3D visualization, audio and video software, and games. With that, efficiency and security of code on the Web has become more important than ever. Yet JavaScript as the only built-in language of the Web is not well-equipped to meet these requirements, especially as a compilation target.     Engineers from the four major browser vendors have risen to the challenge and collaboratively designed a portable low-level bytecode called WebAssembly. It offers compact representation, efficient validation and compilation, and safe low to no-overhead execution. Rather than committing to a specific programming model, WebAssembly is an abstraction over modern hardware, making it language-, hardware-, and platform-independent, with use cases beyond just the Web. WebAssembly has been designed with a formal semantics from the start. We describe the motivation, design and formal semantics of WebAssembly and provide some preliminary experience with implementations.}
}

@misc{Cheerps2018,
  title        = {{Cheerp - C++ for the Web}},
  year         = {2018},
  author       = {{Cheerp}},
  url          = {https://www.leaningtech.com/cheerp/},
  lastaccessed = {2019-11-12}
}


@misc{asmjs,
  title        = {{asm.js Speedups Everywhere}},
  year         = {2015},
  author       = {{Alon Zakai}},
  url          = {https://hacks.mozilla.org/2015/03/asm-speedups-everywhere/},
  lastaccessed = {2022-13-04}
}

@misc{wasm_spec,
  title        = {{WebAssembly Specification}},
  year         = {2017},
  author       = {{WebAssembly Community Group}},
  url          = {https://webassembly.github.io/spec/core/syntax/index.html},
  lastaccessed = {2022-13-04}
}


@misc{wasm_roadmap,
  title        = {{WebAssembly Roadmap}},
  year         = {2017},
  author       = {{WebAssembly Community Group}},
  url          = {https://webassembly.org/roadmap/},
  lastaccessed = {2022-13-04}
}


@inproceedings{bryant2020webassembly,
  title     = {Webassembly outside the browser: A new foundation for pervasive computing},
  author    = {Bryant, David},
  booktitle = {Proc. of ICWE 2020},
  pages     = {9--12},
  year      = {2020}
}


@inproceedings{Narayan2021Swivel,
  title     = {Swivel: Hardening WebAssembly against Spectre},
  author    = {Narayan, Shravan and Disselkoen, Craig and Moghimi, Daniel and Cauligi, Sunjay and Johnson, Evan and Gang, Zhao and Vahldiek-Oberwagner, Anjo and Sahita, Ravi and Shacham, Hovav and Tullsen, Dean and others},
  booktitle = {USENIX Security Symposium },
  year      = {2021}
}


% Diversification papers
@article{cohen1993operating,
  title   = {Operating system protection through program evolution.},
  author  = {Cohen, Frederick B},
  journal = {Computers \& Security},
  volume  = {12},
  number  = {6},
  pages   = {565--584},
  year    = {1993}
}

@incollection{jackson2011compiler,
  title     = {Compiler-generated software diversity},
  author    = {Jackson, Todd and Salamat, Babak and Homescu, Andrei and Manivannan, Karthikeyan and Wagner, Gregor and Gal, Andreas and Brunthaler, Stefan and Wimmer, Christian and Franz, Michael},
  booktitle = {Moving Target Defense},
  pages     = {77--98},
  year      = {2011},
  publisher = {Springer}
}

@article{Genkin2018DrivebyKC,
  title   = {Drive-by Key-Extraction Cache Attacks from Portable Code},
  author  = {Daniel Genkin and Lev Pachmanov and Eran Tromer and Yuval Yarom},
  journal = {IACR Cryptol. ePrint Arch.},
  year    = {2018},
  volume  = {2018},
  pages   = {119}
}


@inproceedings{homescu2013profile,
  title        = {Profile-guided automated software diversity},
  author       = {Homescu, Andrei and Neisius, Steven and Larsen, Per and Brunthaler, Stefan and Franz, Michael},
  booktitle    = {Proceedings of the 2013 IEEE/ACM International Symposium on Code Generation and Optimization (CGO)},
  pages        = {1--11},
  year         = {2013},
  organization = {IEEE}
}

@article{coppens2013feedback,
  title     = {Feedback-driven binary code diversification},
  author    = {Coppens, Bart and De Sutter, Bjorn and Maebe, Jonas},
  journal   = {ACM Transactions on Architecture and Code Optimization (TACO)},
  volume    = {9},
  number    = {4},
  pages     = {1--26},
  year      = {2013},
  publisher = {ACM New York, NY, USA}
}

% Superoptimization

@article{bunel_learning_2017,
  author        = {{Bunel}, Rudy and {Desmaison}, Alban and {Pawan Kumar}, M. and
                   {Torr}, Philip H.S. and {Kohli}, Pushmeet},
  title         = {{Learning to superoptimize programs}},
  journal       = {arXiv e-prints},
  keywords      = {Computer Science - Machine Learning},
  year          = 2016,
  month         = nov,
  number        = 1,
  volume        = 1,
  numpages      = {10},
  eid           = {arXiv:1611.01787},
  pages         = {arXiv:1611.01787},
  archiveprefix = {arXiv},
  eprint        = {1611.01787},
  primaryclass  = {cs.LG},
  adsurl        = {https://ui.adsabs.harvard.edu/abs/2016arXiv161101787B},
  adsnote       = {Provided by the SAO/NASA Astrophysics Data System}
}


@article{Massalin1987,
  title     = {{Superoptimizer: a look at the smallest program}},
  year      = {1987},
  journal   = {ACM SIGARCH Computer Architecture News},
  author    = {Massalin Henry},
  number    = {5},
  month     = {Nov},
  pages     = {122--126},
  volume    = {15},
  publisher = {ACM},
  url       = {http://portal.acm.org/citation.cfm?doid=36177.36194},
  isbn      = {0-8186-0805-6},
  doi       = {10.1145/36177.36194},
  issn      = {01635964}
}


@article{churchill_sound_nodate,
  author     = {Churchill, Berkeley and Sharma, Rahul and Bastien, JF and Aiken, Alex},
  title      = {Sound Loop Superoptimization for Google Native Client},
  year       = {2017},
  issue_date = {May 2017},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {52},
  number     = {4},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/3093336.3037754},
  doi        = {10.1145/3093336.3037754},
  journal    = {SIGPLAN Not.},
  pages      = {313–326},
  numpages   = {14},
  keywords   = {verification, bounded verification, superoptimization, assembly, x86-64, equivalence checking, data-driven verification, native client}
}


% Superdiversifier
@inproceedings{jacob2008superdiversifier,
  title        = {The superdiversifier: Peephole individualization for software protection},
  author       = {Jacob, Matthias and Jakubowski, Mariusz H and Naldurg, Prasad and Saw, Chit Wei Nick and Venkatesan, Ramarathnam},
  booktitle    = {International Workshop on Security},
  pages        = {100--120},
  year         = {2008},
  organization = {Springer}
}

@inproceedings{bansal_automatic_nodate,
  author    = {Bansal, Sorav and Aiken, Alex},
  title     = {Automatic Generation of Peephole Superoptimizers},
  year      = {2006},
  isbn      = {1595934510},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1168857.1168906},
  doi       = {10.1145/1168857.1168906},
  booktitle = {Proceedings of the 12th International Conference on Architectural Support for Programming Languages and Operating Systems},
  pages     = {394–403},
  numpages  = {10},
  keywords  = {peephole optimization, code selection, superoptimization},
  location  = {San Jose, California, USA},
  series    = {ASPLOS XII}
}


@inproceedings{Sledge,
  author    = {Gadepalli, Phani Kishore and McBride, Sean and Peach, Gregor and Cherkasova, Ludmila and Parmer, Gabriel},
  title     = {Sledge: A Serverless-First, Light-Weight Wasm Runtime for the Edge},
  year      = {2020},
  doi       = {10.1145/3423211.3425680},
  booktitle = {Proceedings of the 21st International Middleware Conference},
  pages     = {265–279}
}

@inproceedings{wen2020wasmachine,
  title        = {Wasmachine: Bring iot up to speed with a webassembly os},
  author       = {Wen, Elliott and Weber, Gerald},
  booktitle    = {2020 IEEE International Conference on Pervasive Computing and Communications Workshops (PerCom Workshops)},
  pages        = {1--4},
  year         = {2020},
  organization = {IEEE}
}


@misc{WebAssemblySecurity,
  title        = {{WebAssembly documentation: Security}},
  url          = {https://webassembly.org/docs/security/},
  organization = {{W3C}},
  note         = {{Accessed: 18 June 2020}},
  author       = {Dominic Chen and {\relax W3C group}},
  year         = {2020}
}

@inproceedings{usenixWasm2020,
  title     = {Everything Old is New Again: Binary Security of WebAssembly},
  booktitle = {29th USENIX Security Symposium (USENIX Security 20)},
  year      = {2020},
  publisher = {USENIX Association},
  month     = aug,
  author    = {Lehmann, Daniel and Kinder, Johannes and Pradel, Michael}
}


@techreport{ChromeZero,
  title  = {The Problems and Promise of WebAssembly},
  year   = 2018,
  author = {Silvanovich, Natalie},
  month  = mar,
  editor = {Silvanovich, Natalie},
  url    = {https://googleprojectzero.blogspot.com/2018/08/the-problems-and-promise-of-webassembly.html}
}

@inbook{UnleashingCompilerRen,
  author    = {Ren, Xiaolei and Ho, Michael and Ming, Jiang and Lei, Yu and Li, Li},
  title     = {Unleashing the Hidden Power of Compiler Optimization on Binary Code Difference: An Empirical Study},
  year      = {2021},
  isbn      = {9781450383912},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3453483.3454035},
  abstract  = {Hunting binary code difference without source code (i.e., binary diffing) has compelling applications in software security. Due to the high variability of binary code, existing solutions have been driven towards measuring semantic similarities from syntactically different code. Since compiler optimization is the most common source contributing to binary code differences in syntax, testing the resilience against the changes caused by different compiler optimization settings has become a standard evaluation step for most binary diffing approaches. For example, 47 top-venue papers in the last 12 years compared different program versions compiled by default optimization levels (e.g., -Ox in GCC and LLVM). Although many of them claim they are immune to compiler transformations, it is yet unclear about their resistance to non-default optimization settings. Especially, we have observed that adversaries explored non-default compiler settings to amplify malware differences.  This paper takes the first step to systematically studying the effectiveness of compiler optimization on binary code differences. We tailor search-based iterative compilation for the auto-tuning of binary code differences. We develop BinTuner to search near-optimal optimization sequences that can maximize the amount of binary code differences. We run BinTuner with GCC 10.2 and LLVM 11.0 on SPEC benchmarks (CPU2006 &amp; CPU2017), Coreutils, and OpenSSL. Our experiments show that at the cost of 279 to 1,881 compilation iterations, BinTuner can find custom optimization sequences that are substantially better than the general -Ox settings. BinTuner's outputs seriously undermine prominent binary diffing tools' comparisons. In addition, the detection rate of the IoT malware variants tuned by BinTuner falls by more than 50%. Our findings paint a cautionary tale for security analysts that attackers have a new way to mutate malware code cost-effectively, and the research community needs to step back to reassess optimization-resistance evaluations.},
  booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
  pages     = {142–157},
  numpages  = {16}
}


@inproceedings{amarilli2011can,
  title        = {Can code polymorphism limit information leakage?},
  author       = {Amarilli, Antoine and M{\"u}ller, Sascha and Naccache, David and Page, Daniel and Rauzy, Pablo and Tunstall, Michael},
  booktitle    = {IFIP International Workshop on Information Security Theory and Practices},
  pages        = {1--21},
  year         = {2011},
  organization = {Springer}
}


@article{agosta2015meet,
  title     = {The {MEET} approach: Securing cryptographic embedded software against side channel attacks},
  author    = {Agosta, Giovanni and Barenghi, Alessandro and Pelosi, Gerardo and Scandale, Michele},
  journal   = {IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems},
  volume    = {34},
  number    = {8},
  pages     = {1320--1333},
  year      = {2015},
  publisher = {IEEE}
}


@inproceedings{crane2015thwarting,
  title     = {Thwarting Cache Side-Channel Attacks Through Dynamic Software Diversity.},
  author    = {Crane, Stephen and Homescu, Andrei and Brunthaler, Stefan and Larsen, Per and Franz, Michael},
  booktitle = {NDSS},
  pages     = {8--11},
  year      = {2015}
}


@inproceedings{courousse2016runtime,
  title        = {Runtime code polymorphism as a protection against side channel attacks},
  author       = {Courouss{\'e}, Damien and Barry, Thierno and Robisson, Bruno and Jaillon, Philippe and Potin, Olivier and Lanet, Jean-Louis},
  booktitle    = {IFIP International Conference on Information Security Theory and Practice},
  pages        = {136--152},
  year         = {2016},
  organization = {Springer}
}


@inproceedings{bruschi2007diversified,
  title     = {Diversified process replic{\ae} for defeating memory error exploits},
  author    = {Bruschi, Danilo and Cavallaro, Lorenzo and Lanzi, Andrea},
  booktitle = {Proc. of the Int. Performance, Computing, and Communications Conference},
  year      = {2007}
}


@inproceedings{cox06,
  title     = {N-variant systems: a secretless framework for security through diversity},
  author    = {Cox, Benjamin and Evans, David and Filipi, Adrian and Rowanhill, Jonathan and Hu, Wei and Davidson, Jack and Knight, John and Nguyen-Tuong, Anh and Hiser, Jason},
  booktitle = {Proc. of USENIX Security Symposium},
  year      = {2006},
  series    = {USENIX-SS'06},
  location  = {Vancouver, B.C., Canada},
  url       = {http://dl.acm.org/citation.cfm?id=1267336.1267344}
}


@techreport{salamat2007stopping,
  title       = {Stopping Buffer Overflow Attacks at Run-Time: Simultaneous Multi-Variant Program Execution on a Multicore Processor},
  author      = {Salamat, Babak and Gal, Andreas and Jackson, Todd and Manivannan, Karthik and Wagner, Gregor and Franz, Michael},
  year        = {2007},
  institution = {Technical Report 07-13, School of Information and Computer Sciences, UCIrvine}
}



@article{lu2018stopping,
  title     = {Stopping memory disclosures via diversification and replicated execution},
  author    = {Lu, Kangjie and Xu, Meng and Song, Chengyu and Kim, Taesoo and Lee, Wenke},
  journal   = {IEEE Transactions on Dependable and Secure Computing},
  year      = {2018},
  publisher = {IEEE}
}

@article{volckaert2015cloning,
  title   = {Cloning your gadgets: Complete ROP attack immunity with multi-variant execution},
  author  = {Volckaert, Stijn and Coppens, Bart and De Sutter, Bjorn},
  journal = {IEEE Transactions on Dependable and Secure Computing},
  volume  = {13},
  number  = {4},
  year    = {2015}
}


@article{SalamatJWWF11,
  author    = {Babak Salamat and
               Todd Jackson and
               Gregor Wagner and
               Christian Wimmer and
               Michael Franz},
  title     = {Runtime Defense against Code Injection Attacks Using Replicated Execution},
  journal   = {{IEEE} Trans. Dependable Secur. Comput.},
  volume    = {8},
  number    = {4},
  pages     = {588--601},
  year      = {2011},
  url       = {https://doi.org/10.1109/TDSC.2011.18},
  doi       = {10.1109/TDSC.2011.18},
  timestamp = {Thu, 09 Apr 2020 17:07:58 +0200},
  biburl    = {https://dblp.org/rec/journals/tdsc/SalamatJWWF11.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}


@inproceedings{osterlund2019kmvx,
  title     = {kMVX: Detecting kernel information leaks with multi-variant execution},
  author    = {{\"O}sterlund, Sebastian and Koning, Koen and Olivier, Pierre and Barbalace, Antonio and Bos, Herbert and Giuffrida, Cristiano},
  booktitle = {ASPLOS},
  year      = {2019}
}


@inproceedings{salamat2009orchestra,
  title     = {Orchestra: intrusion detection using parallel execution and monitoring of program variants in user-space},
  author    = {Salamat, Babak and Jackson, Todd and Gal, Andreas and Franz, Michael},
  booktitle = {Proceedings of the 4th ACM European conference on Computer systems},
  pages     = {33--46},
  year      = {2009}
}


@inproceedings{koning2016secure,
  title        = {Secure and efficient multi-variant execution using hardware-assisted process virtualization},
  author       = {Koning, Koen and Bos, Herbert and Giuffrida, Cristiano},
  booktitle    = {2016 46th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)},
  pages        = {431--442},
  year         = {2016},
  organization = {IEEE}
}


@article{10.1145/3281662,
  author     = {Belleville, Nicolas and Courouss\'{e}, Damien and Heydemann, Karine and Charles, Henri-Pierre},
  title      = {Automated Software Protection for the Masses Against Side-Channel Attacks},
  year       = {2018},
  issue_date = {December 2018},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {15},
  number     = {4},
  issn       = {1544-3566},
  url        = {https://doi.org/10.1145/3281662},
  doi        = {10.1145/3281662},
  abstract   = {We present an approach and a tool to answer the need for effective, generic, and easily applicable protections against side-channel attacks. The protection mechanism is based on code polymorphism, so that the observable behaviour of the protected component is variable and unpredictable to the attacker. Our approach combines lightweight specialized runtime code generation with the optimization capabilities of static compilation. It is extensively configurable. Experimental results show that programs secured by our approach present strong security levels and meet the performance requirements of constrained systems.},
  journal    = {ACM Trans. Archit. Code Optim.},
  month      = {nov},
  articleno  = {47},
  numpages   = {27},
  keywords   = {runtime code generation, hiding, polymorphism, compilation, Side-channel attack}
}


@inproceedings{maurer2012tachyon,
  title     = {TACHYON: Tandem execution for efficient live patch testing},
  author    = {Maurer, Matthew and Brumley, David},
  booktitle = {21st USENIX Security Symposium (USENIX Security 12)},
  pages     = {617--630},
  year      = {2012}
}

@article{Kim2015,
  title   = {Dual Execution for On the Fly Fine Grained Execution Comparison},
  author  = {Kim, Dohyeong and Kwon, Yonghwi and Sumner, William N. and Zhang, Xiangyu and Xu, Dongyan},
  journal = {SIGPLAN Not.},
  year    = {2015}
}



@inproceedings{voulimeneas2021dmvx,
  title     = {dMVX: Secure and Efficient Multi-Variant Execution in a Distributed Setting},
  author    = {Voulimeneas, Alexios and Song, Dokyung and Larsen, Per and Franz, Michael and Volckaert, Stijn},
  booktitle = {Proceedings of the 14th European Workshop on Systems Security},
  pages     = {41--47},
  year      = {2021}
}

@inproceedings{9640153,
  author    = {Spies, Benedikt and Mock, Markus},
  booktitle = {2021 XLVII Latin American Computing Conference (CLEI)},
  title     = {An Evaluation of WebAssembly in Non-Web Environments},
  year      = {2021},
  volume    = {},
  number    = {},
  pages     = {1-10},
  doi       = {10.1109/CLEI53233.2021.9640153}
}


@article{natural_diversity,
  author     = {Baudry, Benoit and Monperrus, Martin},
  title      = {The Multiple Facets of Software Diversity: Recent Developments in Year 2000 and Beyond},
  year       = {2015},
  issue_date = {September 2015},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {48},
  number     = {1},
  issn       = {0360-0300},
  url        = {https://doi.org/10.1145/2807593},
  doi        = {10.1145/2807593},
  abstract   = {Early experiments with software diversity in the mid 1970s investigated N-version programming and recovery blocks to increase the reliability of embedded systems. Four decades later, the literature about software diversity has expanded in multiple directions: goals (fault tolerance, security, software engineering), means (managed or automated diversity), and analytical studies (quantification of diversity and its impact). Our article contributes to the field of software diversity as the first work that adopts an inclusive vision of the area, with an emphasis on the most recent advances in the field. This survey includes classical work about design and data diversity for fault tolerance, as well as the cybersecurity literature that investigates randomization at different system levels. It broadens this standard scope of diversity to include the study and exploitation of natural diversity and the management of diverse software products. Our survey includes the most recent works, with an emphasis from 2000 to the present. The targeted audience is researchers and practitioners in one of the surveyed fields who miss the big picture of software diversity. Assembling the multiple facets of this fascinating topic sheds a new light on the field.},
  journal    = {ACM Comput. Surv.},
  month      = {sep},
  articleno  = {16},
  numpages   = {26},
  keywords   = {design principles, Software diversity, program transformation}
}

@inproceedings{SMT_solver,
  author    = {de Moura, Leonardo
               and Bj{\o}rner, Nikolaj},
  editor    = {Ramakrishnan, C. R.
               and Rehof, Jakob},
  title     = {Z3: An Efficient SMT Solver},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
  year      = {2008},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {337--340},
  abstract  = {Satisfiability Modulo Theories (SMT) problem is a decision problem for logical first order formulas with respect to combinations of background theories such as: arithmetic, bit-vectors, arrays, and uninterpreted functions. Z3 is a new and efficient SMT Solver freely available from Microsoft Research. It is used in various software verification and analysis applications.},
  isbn      = {978-3-540-78800-3}
}



@article{2021arXiv210913498S,
  author        = {{Shypula}, Alex and {Yin}, Pengcheng and {Lacomis}, Jeremy and {Le Goues}, Claire and {Schwartz}, Edward and {Neubig}, Graham},
  title         = {{Learning to Superoptimize Real-world Programs}},
  journal       = {arXiv e-prints},
  keywords      = {Computer Science - Machine Learning, Computer Science - Artificial Intelligence, Computer Science - Programming Languages, Computer Science - Software Engineering},
  year          = 2021,
  month         = sep,
  eid           = {arXiv:2109.13498},
  pages         = {arXiv:2109.13498},
  archiveprefix = {arXiv},
  eprint        = {2109.13498},
  primaryclass  = {cs.LG},
  adsurl        = {https://ui.adsabs.harvard.edu/abs/2021arXiv210913498S},
  adsnote       = {Provided by the SAO/NASA Astrophysics Data System}
}


@inproceedings{bhatkar03,
  title     = {Address obfuscation: an efficient approach to combat a board range of memory error exploits},
  author    = {Bhatkar, Sandeep and DuVarney, Daniel C. and Sekar, R.},
  booktitle = {Proceedings of the USENIX Security Symposium},
  year      = {2003}
}



@inproceedings{Kc03,
  title     = {Countering code-injection attacks with instruction-set randomization},
  author    = {Kc, Gaurav S. and Keromytis, Angelos D. and Prevelakis, Vassilis},
  booktitle = {Proc. of CCS},
  year      = {2003},
  pages     = {272--280}
}


@inproceedings{barrantes2003randomized,
  title     = {Randomized instruction set emulation to disrupt binary code injection attacks},
  author    = {Barrantes, Elena Gabriela and Ackley, David H and Forrest, Stephanie and Palmer, Trek S and Stefanovic, Darko and Zovi, Dino Dai},
  booktitle = {Proc. CCS},
  pages     = {281--289},
  year      = {2003}
}


@phdthesis{jackson,
  title  = {On the Design, Implications, and Effects of Implementing Software Diversity for Security},
  author = {Todd Jackson},
  school = {University of California, Irvine},
  year   = {2012}
}


@techreport{Chew02mitigatingbuffer,
  title       = {Mitigating buffer overflows by operating system randomization},
  author      = { Chew, Monica and  Song, Dawn},
  institution = {Carnegie Mellon University},
  year        = {2002},
  number      = {CS-02-197}
}

@inproceedings{bhatkar2005efficient,
  title     = {Efficient techniques for comprehensive protection from memory error exploits},
  author    = {Bhatkar, Sandeep and Sekar, Ron and DuVarney, Daniel C},
  booktitle = {Proceedings of the USENIX Security Symposium},
  year      = {2005},
  pages     = {271--286}
}


@inproceedings{aga2019smokestack,
  title     = {Smokestack: thwarting DOP attacks with runtime stack layout randomization},
  author    = {Aga, Misiker Tadesse and Austin, Todd},
  booktitle = {Proc. of CGO},
  pages     = {26--36},
  year      = {2019},
  url       = {https://drive.google.com/file/d/12TvsrgL8Wt6IMfe6ASUp8y69L-bCVao0/view}
}


@article{lee2021savior,
  title   = {SaVioR: Thwarting Stack-Based Memory Safety Violations by Randomizing Stack Layout},
  author  = {Lee, Seongman and Kang, Hyeonwoo and Jang, Jinsoo and Kang, Brent Byunghoon},
  journal = {IEEE Transactions on Dependable and Secure Computing},
  year    = {2021},
  url     = {https://ieeexplore.ieee.org/iel7/8858/4358699/09369900.pdf}
}



@inproceedings{xu2020merr,
  title     = {Merr: Improving security of persistent memory objects via efficient memory exposure reduction and randomization},
  author    = {Xu, Yuanchao and Solihin, Yan and Shen, Xipeng},
  booktitle = {Proc. of ASPLOS},
  pages     = {987--1000},
  year      = {2020},
  url       = {https://dl.acm.org/doi/pdf/10.1145/3373376.3378492}
}



@inproceedings{10.1145/2384616.2384628,
  author    = {Kulkarni, Sameer and Cavazos, John},
  title     = {Mitigating the Compiler Optimization Phase-Ordering Problem Using Machine Learning},
  year      = {2012},
  isbn      = {9781450315616},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2384616.2384628},
  doi       = {10.1145/2384616.2384628},
  abstract  = {Today's compilers have a plethora of optimizations to choose from, and the correct choice of optimizations can have a significant impact on the performance of the code being optimized. Furthermore, choosing the correct order in which to apply those optimizations has been a long standing problem in compilation research. Each of these optimizations interacts with the code and in turn with all other optimizations in complicated ways. Traditional compilers typically apply the same set of optimization in a fixed order to all functions in a program, without regard the code being optimized.Understanding the interactions of optimizations is very important in determining a good solution to the phase-ordering problem. This paper develops a new approach that automatically selects good optimization orderings on a per method basis within a dynamic compiler. Our approach formulates the phase-ordering problem as a Markov process and uses a characterization of the current state of the code being optimized to creating a better solution to the phase ordering problem. Our technique uses neuro-evolution to construct an artificial neural network that is capable of predicting beneficial optimization ordering for a piece of code that is being optimized. We implemented our technique in Jikes RVM and achieved significant improvements on a set of standard Java benchmarks over a well-engineered fixed order.},
  booktitle = {Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications},
  pages     = {147–162},
  numpages  = {16},
  keywords  = {neural networks, machine learning, java, jikes rvm, phase ordering, compiler optimization, source code feature generation},
  location  = {Tucson, Arizona, USA},
  series    = {OOPSLA '12}
}

@article{phase-ordering-problem,
  author     = {Kulkarni, Sameer and Cavazos, John},
  title      = {Mitigating the Compiler Optimization Phase-Ordering Problem Using Machine Learning},
  year       = {2012},
  issue_date = {October 2012},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {47},
  number     = {10},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/2398857.2384628},
  doi        = {10.1145/2398857.2384628},
  abstract   = {Today's compilers have a plethora of optimizations to choose from, and the correct choice of optimizations can have a significant impact on the performance of the code being optimized. Furthermore, choosing the correct order in which to apply those optimizations has been a long standing problem in compilation research. Each of these optimizations interacts with the code and in turn with all other optimizations in complicated ways. Traditional compilers typically apply the same set of optimization in a fixed order to all functions in a program, without regard the code being optimized.Understanding the interactions of optimizations is very important in determining a good solution to the phase-ordering problem. This paper develops a new approach that automatically selects good optimization orderings on a per method basis within a dynamic compiler. Our approach formulates the phase-ordering problem as a Markov process and uses a characterization of the current state of the code being optimized to creating a better solution to the phase ordering problem. Our technique uses neuro-evolution to construct an artificial neural network that is capable of predicting beneficial optimization ordering for a piece of code that is being optimized. We implemented our technique in Jikes RVM and achieved significant improvements on a set of standard Java benchmarks over a well-engineered fixed order.},
  journal    = {SIGPLAN Not.},
  month      = {oct},
  pages      = {147–162},
  numpages   = {16},
  keywords   = {compiler optimization, machine learning, phase ordering, jikes rvm, java, neural networks, source code feature generation}
}


@misc{MTDNationalCyberLaep,
  title   = {{National Cyber Leap Year}},
  url     = {https://www.nitrd.gov/nitrdgroups/index.php?title=National_Cyber_Leap_Year},
  urldate = {2021-02-02},
  year    = {2021}
}

@inproceedings{10.1145/3318216.3363338,
  author    = {Roy, Abhishek and Chhabra, Anshuman and Kamhoua, Charles A. and Mohapatra, Prasant},
  title     = {A Moving Target Defense against Adversarial Machine Learning},
  year      = {2019},
  booktitle = {Proceedings of the 4th ACM/IEEE Symposium on Edge Computing},
  pages     = {383–388}
}

@inproceedings{10.5555/3091125.3091155,
  author    = {Sengupta, Sailik and Vadlamudi, Satya Gautam and Kambhampati, Subbarao and Doup\'{e}, Adam and Zhao, Ziming and Taguinod, Marthony and Ahn, Gail-Joon},
  title     = {A Game Theoretic Approach to Strategy Generation for Moving Target Defense in Web Applications},
  year      = {2017},
  booktitle = {Proceedings of the 16th Conference on Autonomous Agents and MultiAgent Systems},
  pages     = {178–186},
  numpages  = {9},
  keywords  = {moving target defense, bayesian games, stackelberg equilibrium, security games}
}

@inproceedings{EsAsm.js,
  author    = {Van Es, Noah and Nicolay, Jens and Stievenart, Quentin and D'Hondt, Theo and De Roover, Coen},
  title     = {A Performant Scheme Interpreter in Asm.Js},
  year      = {2016},
  isbn      = {9781450337397},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2851613.2851748},
  doi       = {10.1145/2851613.2851748},
  abstract  = {This paper presents the implementation of an efficient interpreter for a Scheme-like language using manually written asm.js code. The asm.js specification defines an optimizable subset of JavaScript which has already served well as a compilation target for web applications where performance is critical. However, its usage as a human-writable language that can be integrated into existing projects to improve performance has remained largely unexplored. We therefore apply this strategy to optimize the implementation of an interpreter. We also discuss the feasibility of this approach, as writing asm.js by hand is generally not its recommended use-case. We therefore present a macro system to solve the challenges we encounter. The resulting interpreter is compared to the original C implementation and its compiled equivalent in asm.js. This way, we evaluate whether manual integration with asm.js provides the necessary performance to bring larger applications and runtimes to the web.},
  booktitle = {Proceedings of the 31st Annual ACM Symposium on Applied Computing},
  pages     = {1944–1951},
  numpages  = {8},
  keywords  = {asm.js, JavaScript, optimization},
  location  = {Pisa, Italy},
  series    = {SAC '16}
}



@article{NEEDLEMAN1970443,
  title        = {A General Method Applicable to the Search for Similarities in the Amino Acid Sequence of Two Proteins},
  volume       = {48},
  issn         = {0022-2836},
  url          = {http://www.sciencedirect.com/science/article/pii/0022283670900574},
  doi          = {https://doi.org/10.1016/0022-2836(70)90057-4},
  abstract     = {A computer adaptable method for finding similarities in the amino acid sequences of two proteins has been developed. From these findings it is possible to determine whether significant homology exists between the proteins. This information is used to trace their possible evolutionary development. The maximum match is a number dependent upon the similarity of the sequences. One of its definitions is the largest number of amino acids of one protein that can be matched with those of a second protein allowing for all possible interruptions in either of the sequences. While the interruptions give rise to a very large number of comparisons, the method efficiently excludes from consideration those comparisons that cannot contribute to the maximum match. Comparisons are made from the smallest unit of significance, a pair of amino acids, one from each protein. All possible pairs are represented by a two-dimensional array, and all possible comparisons are represented by pathways through the array. For this maximum match only certain of the possible pathways must be evaluated. A numerical value, one in this case, is assigned to every cell in the array representing like amino acids. The maximum match is the largest number that would result from summing the cell values of every pathway.},
  number       = {3},
  journaltitle = {Journal of Molecular Biology},
  shortjournal = {J. Mol. Biol.},
  date         = {1970},
  year         = {1970},
  pages        = {443-453},
  author       = {Needleman, Saul B. and Wunsch, Christian D.}
}

@inproceedings{shillaker2020faasm,
  title     = {Faasm: Lightweight isolation for efficient stateful serverless computing},
  author    = {Shillaker, Simon and Pietzuch, Peter},
  booktitle = {USENIX Annual Technical Conference},
  pages     = {419--433},
  year      = {2020}
}

@article{morgan2015web,
  title   = {Web timing attacks made practical},
  author  = {Morgan, Timothy D and Morgan, Jason W},
  journal = {Black Hat},
  year    = {2015}
}

@inproceedings{595185,
  author    = {Forrest, S. and Somayaji, A. and Ackley, D.H.},
  booktitle = {Proceedings. The Sixth Workshop on Hot Topics in Operating Systems (Cat. No.97TB100133)},
  title     = {Building diverse computer systems},
  year      = {1997},
  volume    = {},
  number    = {},
  pages     = {67-72},
  doi       = {10.1109/HOTOS.1997.595185}
}


@article{10.1145/390016.808467,
  author     = {Randell, B.},
  title      = {System Structure for Software Fault Tolerance},
  year       = {1975},
  issue_date = {June 1975},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {10},
  number     = {6},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/390016.808467},
  doi        = {10.1145/390016.808467},
  abstract   = {The paper presents, and discusses the rationale behind, a method for structuring complex computing systems by the use of what we term “recovery blocks”, “conversations” and “fault-tolerant interfaces”. The aim is to facilitate the provision of dependable error detection and recovery facilities which can cope with errors caused by residual design inadequacies, particularly in the system software, rather than merely the occasional malfunctioning of hardware components.},
  journal    = {SIGPLAN Not.},
  month      = {apr},
  pages      = {437–449},
  numpages   = {13},
  keywords   = {Recursive cache, Alternate block, Error recovery, Conversation, Acceptance test, Error detection, Checkpoint, Recovery block}
}

@article{1659219,
  author  = {Avizienis and Kelly},
  journal = {Computer},
  title   = {Fault Tolerance by Design Diversity: Concepts and Experiments},
  year    = {1984},
  volume  = {17},
  number  = {8},
  pages   = {67-80},
  doi     = {10.1109/MC.1984.1659219}
}
@article{CHEN201060,
  title    = {Adaptive Random Testing: The ART of test case diversity},
  journal  = {Journal of Systems and Software},
  volume   = {83},
  number   = {1},
  pages    = {60-66},
  year     = {2010},
  note     = {SI: Top Scholars},
  issn     = {0164-1212},
  doi      = {https://doi.org/10.1016/j.jss.2009.02.022},
  url      = {https://www.sciencedirect.com/science/article/pii/S0164121209000405},
  author   = {Tsong Yueh Chen and Fei-Ching Kuo and Robert G. Merkel and T.H. Tse},
  keywords = {Software testing, Random testing, Adaptive random testing, Adaptive random sequence, Failure-based testing, Failure pattern},
  abstract = {Random testing is not only a useful testing technique in itself, but also plays a core role in many other testing methods. Hence, any significant improvement to random testing has an impact throughout the software testing community. Recently, Adaptive Random Testing (ART) was proposed as an effective alternative to random testing. This paper presents a synthesis of the most important research results related to ART. In the course of our research and through further reflection, we have realised how the techniques and concepts of ART can be applied in a much broader context, which we present here. We believe such ideas can be applied in a variety of areas of software testing, and even beyond software testing. Amongst these ideas, we particularly note the fundamental role of diversity in test case selection strategies. We hope this paper serves to provoke further discussions and investigations of these ideas.}
}

@book{pohl2005software,
  title     = {Software product line engineering: foundations, principles, and techniques},
  author    = {Pohl, Klaus and B{\"o}ckle, G{\"u}nter and Van Der Linden, Frank},
  volume    = {1},
  year      = {2005},
  publisher = {Springer}
}

@article{Chen2010AdaptiveRT,
  title   = {Adaptive Random Testing: The ART of test case diversity},
  author  = {Tsong Yueh Chen and Fei-Ching Kuo and Robert G. Merkel and T. H. Tse},
  journal = {J. Syst. Softw.},
  year    = {2010},
  volume  = {83},
  pages   = {60-66}
}

@inproceedings{10.1145/2025113.2025133,
  author    = {Sidiroglou-Douskos, Stelios and Misailovic, Sasa and Hoffmann, Henry and Rinard, Martin},
  title     = {Managing Performance vs. Accuracy Trade-Offs with Loop Perforation},
  year      = {2011},
  isbn      = {9781450304436},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2025113.2025133},
  doi       = {10.1145/2025113.2025133},
  abstract  = {Many modern computations (such as video and audio encoders, Monte Carlo simulations, and machine learning algorithms) are designed to trade off accuracy in return for increased performance. To date, such computations typically use ad-hoc, domain-specific techniques developed specifically for the computation at hand. Loop perforation provides a general technique to trade accuracy for performance by transforming loops to execute a subset of their iterations. A criticality testing phase filters out critical loops (whose perforation produces unacceptable behavior) to identify tunable loops (whose perforation produces more efficient and still acceptably accurate computations). A perforation space exploration algorithm perforates combinations of tunable loops to find Pareto-optimal perforation policies. Our results indicate that, for a range of applications, this approach typically delivers performance increases of over a factor of two (and up to a factor of seven) while changing the result that the application produces by less than 10%.},
  booktitle = {Proceedings of the 19th ACM SIGSOFT Symposium and the 13th European Conference on Foundations of Software Engineering},
  pages     = {124–134},
  numpages  = {11},
  keywords  = {profiling, loop perforation, quality of service},
  location  = {Szeged, Hungary},
  series    = {ESEC/FSE '11}
}

@article{okhravi2013survey,
  title   = {Survey of cyber moving targets},
  author  = {Okhravi, H and Rabe, MA and Mayberry, TJ and Leonard, WG and Hobson, TR and Bigelow, D and Streilein, WW},
  journal = {Massachusetts Inst of Technology Lexington Lincoln Lab, No. MIT/LL-TR-1166},
  year    = {2013}
}

@inproceedings{wobfuscator,
  author    = {A. Romano and D. Lehmann and M. Pradel and W. Wang},
  booktitle = {2022 2022 IEEE Symposium on Security and Privacy (SP) (SP)},
  title     = {Wobfuscator: Obfuscating JavaScript Malware via Opportunistic Translation to WebAssembly},
  year      = {2022},
  volume    = {},
  issn      = {2375-1207},
  pages     = {1101-1116},
  keywords  = {webassembly;obfuscation;malware;opportunistic;web},
  doi       = {10.1109/SP46214.2022.00064},
  url       = {https://doi.ieeecomputersociety.org/10.1109/SP46214.2022.00064},
  publisher = {IEEE Computer Society},
  address   = {Los Alamitos, CA, USA},
  month     = {may}
}



@article{johnson2021,
  title={SFI safety for native-compiled Wasm},
  author={Johnson, Evan and Thien, David and Alhessi, Yousef and Narayan, Shravan and Brown, Fraser and Lerner, Sorin and McMullen, Tyler and Savage, Stefan and Stefan, Deian},
  journal={NDSS. Internet Society},
  year={2021}
}



@ARTICLE{MEWE,
       author = {{Cabrera Arteaga}, Javier and {Laperdrix}, Pierre and {Monperrus}, Martin and {Baudry}, Benoit},
        title = "{Multi-Variant Execution at the Edge}",
      journal = {arXiv e-prints},
     keywords = {Computer Science - Software Engineering},
         year = 2021,
        month = aug,
          eid = {arXiv:2108.08125},
        pages = {arXiv:2108.08125},
archivePrefix = {arXiv},
       eprint = {2108.08125},
 primaryClass = {cs.SE},
       adsurl = {https://ui.adsabs.harvard.edu/abs/2021arXiv210808125C},
      adsnote = {Provided by the SAO/NASA Astrophysics Data System}
}

@inproceedings{CROW,
  title={CROW: code diversification for webassembly},
  author={Cabrera Arteaga, Javier and Floros, Orestis and Vera Perez, Oscar and Baudry, Benoit and Monperrus, Martin},
  booktitle={MADWeb, NDSS 2021},
  year={2021}
}

@article{harrand2020java,
  title={Java decompiler diversity and its application to meta-decompilation},
  author={Harrand, Nicolas and Soto-Valero, C{\'e}sar and Monperrus, Martin and Baudry, Benoit},
  journal={Journal of Systems and Software},
  volume={168},
  pages={110645},
  year={2020},
  publisher={Elsevier}
}
@article{Tsoupidi2020ConstraintBasedSD,
  title={Constraint-Based Software Diversification for Efficient Mitigation of Code-Reuse Attacks},
  author={Rodothea Myrsini Tsoupidi and Roberto Casta{\~n}eda Lozano and Beno{\^i}t Baudry},
  journal={ArXiv},
  year={2020},
  volume={abs/2007.08955}
}
@article{10.1145/93548.93550,
author = {Pettis, Karl and Hansen, Robert C.},
title = {Profile Guided Code Positioning},
year = {1990},
issue_date = {Jun. 1990},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {25},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/93548.93550},
doi = {10.1145/93548.93550},
abstract = {This paper presents the results of our investigation of code positioning techniques using execution profile data as input into the compilation process. The primary objective of the positioning is to reduce the overhead of the instruction memory hierarchy.After initial investigation in the literature, we decided to implement two prototypes for the Hewlett-Packard Precision Architecture (PA-RISC). The first, built on top of the linker, positions code based on whole procedures. This prototype has the ability to move procedures into an order that is determined by a “closest is best” strategy.The second prototype, built on top of an existing optimizer package, positions code based on basic blocks within procedures. Groups of basic blocks that would be better as straight-line sequences are identified as chains. These chains are then ordered according to branch heuristics. Code that is never executed during the data collection runs can be physically separated from the primary code of a procedure by a technique we devised called procedure splitting.The algorithms we implemented are described through examples in this paper. The performance improvements from our work are also summarized in various tables and charts.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {16–27},
numpages = {12}
}

@inproceedings{pettisochhansen,
author = {Pettis, Karl and Hansen, Robert C.},
title = {Profile Guided Code Positioning},
year = {1990},
isbn = {0897913647},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/93542.93550},
doi = {10.1145/93542.93550},
abstract = {This paper presents the results of our investigation of code positioning techniques using execution profile data as input into the compilation process. The primary objective of the positioning is to reduce the overhead of the instruction memory hierarchy.After initial investigation in the literature, we decided to implement two prototypes for the Hewlett-Packard Precision Architecture (PA-RISC). The first, built on top of the linker, positions code based on whole procedures. This prototype has the ability to move procedures into an order that is determined by a “closest is best” strategy.The second prototype, built on top of an existing optimizer package, positions code based on basic blocks within procedures. Groups of basic blocks that would be better as straight-line sequences are identified as chains. These chains are then ordered according to branch heuristics. Code that is never executed during the data collection runs can be physically separated from the primary code of a procedure by a technique we devised called procedure splitting.The algorithms we implemented are described through examples in this paper. The performance improvements from our work are also summarized in various tables and charts.},
booktitle = {Proceedings of the ACM SIGPLAN 1990 Conference on Programming Language Design and Implementation},
pages = {16–27},
numpages = {12},
location = {White Plains, New York, USA},
series = {PLDI '90}
}


@InProceedings{ElKhalil2004,
author="El-Khalil, Rakan
and Keromytis, Angelos D.",
editor="Lopez, Javier
and Qing, Sihan
and Okamoto, Eiji",
title="Hydan: Hiding Information in Program Binaries",
booktitle="Information and Communications Security",
year="2004",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="187--199",
abstract="We present a scheme to steganographically embed information in x86 program binaries. We define sets of functionally-equivalent instructions, and use a key-derived selection process to encode information in machine code by using the appropriate instructions from each set. Such a scheme can be used to watermark (or fingerprint) code, sign executables, or simply create a covert communication channel. We experimentally measure the capacity of the covert channel by determining the distribution of equivalent instructions in several popular operating system distributions. Our analysis shows that we can embed only a limited amount of information in each executable (approximately {\$}{\backslash}frac{\{}1{\}}{\{}110{\}}{\$}bit encoding rate), although this amount is sufficient for some of the potential applications mentioned. We conclude by discussing potential improvements to the capacity of the channel and other future work.",
isbn="978-3-540-30191-2"
}



@article{Cleemput2012,
  author = {Cleemput, Jeroen V. and Coppens, Bart and De Sutter, Bjorn},
  title = {Compiler Mitigations for Time Attacks on Modern X86 Processors},
  year = {2012},
  issue_date = {January 2012},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {8},
  number = {4},
  issn = {1544-3566},
  url = {https://doi.org/10.1145/2086696.2086702},
  doi = {10.1145/2086696.2086702},
  abstract = {This paper studies and evaluates the extent to which automated compiler techniques can defend against timing-based side channel attacks on modern x86 processors. We study how modern x86 processors can leak timing information through side channels that relate to data flow. We study the efficiency, effectiveness, portability, predictability and sensitivity of several mitigating code transformations that eliminate or minimize key-dependent execution time variations. Furthermore, we discuss the extent to which compiler backends are a suitable tool to provide automated support for the proposed mitigations.},
  journal = {ACM Trans. Archit. Code Optim.},
  month = {jan},
  articleno = {23},
  numpages = {20},
  keywords = {variable latency instructions, Time-based side channels, x86 architecture}
}

@INPROCEEDINGS{Younan2006,  author={Younan, Yves and Pozza, Davide and Piessens, Frank and Joosen, Wouter},  booktitle={2006 22nd Annual Computer Security Applications Conference (ACSAC'06)},   title={Extended Protection against Stack Smashing Attacks without Performance Loss},   year={2006},  volume={},  number={},  pages={429-438},  doi={10.1109/ACSAC.2006.27}}